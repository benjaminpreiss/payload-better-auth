{"version":3,"sources":["../../src/better-auth/crypto-shared.ts"],"sourcesContent":["// crypto-shared.ts\nimport crypto from 'crypto'\n\n/**\n * Type for serializable values that can be canonically stringified\n */\ntype SerializableValue =\n  | boolean\n  | null\n  | number\n  | SerializableArray\n  | SerializableObject\n  | string\n  | undefined\n\ninterface SerializableObject {\n  [key: string]: SerializableValue\n}\n\ninterface SerializableArray extends Array<SerializableValue> {}\n\n/**\n * Signature object containing timestamp, nonce, and MAC\n */\nexport interface CryptoSignature {\n  /** HMAC-SHA256 signature */\n  mac: string\n  /** Unique nonce for this signature */\n  nonce: string\n  /** Unix timestamp as string */\n  ts: string\n}\n\n/**\n * Input parameters for signature verification\n */\nexport interface VerifySignatureInput {\n  /** The data that was signed */\n  body: unknown\n  /** Maximum allowed time skew in seconds (default: 300) */\n  maxSkewSec?: number\n  /** Secret key for verification */\n  secret: string\n  /** The signature to verify */\n  signature: CryptoSignature\n}\n\n/**\n * Input parameters for signature creation\n */\nexport interface SignCanonicalInput {\n  /** The data to sign */\n  body: unknown\n  /** Secret key for signing */\n  secret: string\n}\n\n/**\n * Converts an object to a canonical string representation\n * Handles circular references and ensures consistent ordering\n */\nfunction canonicalStringify(obj: unknown): string {\n  const seen = new WeakSet<object>()\n\n  const walk = (v: unknown): string => {\n    if (v && typeof v === 'object') {\n      if (seen.has(v)) {\n        throw new Error('Circular reference detected in object')\n      }\n      seen.add(v)\n\n      if (Array.isArray(v)) {\n        const result = `[${v.map(walk).join(',')}]`\n        seen.delete(v)\n        return result\n      }\n\n      const keys = Object.keys(v).sort()\n      const result = `{${keys.map((k) => `\"${k}\":${walk((v as Record<string, unknown>)[k])}`).join(',')}}`\n      seen.delete(v)\n      return result\n    }\n    return JSON.stringify(v)\n  }\n\n  return walk(obj)\n}\n\n/**\n * Creates a cryptographic signature for the given data\n * @param body - The data to sign\n * @param secret - Secret key for signing\n * @returns Signature object with timestamp, nonce, and MAC\n */\nexport function signCanonical(body: unknown, secret: string): CryptoSignature {\n  if (!secret || typeof secret !== 'string') {\n    throw new Error('Secret must be a non-empty string')\n  }\n\n  const ts = Math.floor(Date.now() / 1000).toString()\n  const nonce = crypto.randomUUID()\n  const payload = canonicalStringify(body)\n  const mac = crypto.createHmac('sha256', secret).update(`${ts}.${nonce}.${payload}`).digest('hex')\n\n  return { mac, nonce, ts }\n}\n\n/**\n * Verifies a cryptographic signature\n * @param body - The original data that was signed\n * @param sig - The signature to verify\n * @param secret - Secret key for verification\n * @param maxSkewSec - Maximum allowed time skew in seconds (default: 300)\n * @returns true if signature is valid, false otherwise\n */\nexport function verifyCanonical(\n  body: unknown,\n  sig: CryptoSignature,\n  secret: string,\n  maxSkewSec: number = 300,\n) {\n  if (!secret || typeof secret !== 'string') {\n    return false\n  }\n\n  if (!sig || typeof sig !== 'object' || !sig.ts || !sig.nonce || !sig.mac) {\n    return false\n  }\n\n  // Validate timestamp\n  const now = Math.floor(Date.now() / 1000)\n  const t = Number(sig.ts)\n  if (!Number.isFinite(t) || Math.abs(now - t) > maxSkewSec) {\n    return false\n  }\n\n  try {\n    const payload = canonicalStringify(body)\n    const expected = crypto\n      .createHmac('sha256', secret)\n      .update(`${sig.ts}.${sig.nonce}.${payload}`)\n      .digest('hex')\n\n    return crypto.timingSafeEqual(\n      new Uint8Array(Buffer.from(sig.mac, 'hex')),\n      new Uint8Array(Buffer.from(expected, 'hex')),\n    )\n  } catch {\n    return false\n  }\n}\n\n/**\n * Convenience function for verifying signatures with input object\n * @param input - Verification parameters\n * @returns true if signature is valid, false otherwise\n */\nexport function verifySignature(input: VerifySignatureInput) {\n  return verifyCanonical(input.body, input.signature, input.secret, input.maxSkewSec)\n}\n\n/**\n * Convenience function for creating signatures with input object\n * @param input - Signing parameters\n * @returns Signature object\n */\nexport function createSignature(input: SignCanonicalInput) {\n  return signCanonical(input.body, input.secret)\n}\n"],"names":["crypto","canonicalStringify","obj","seen","WeakSet","walk","v","has","Error","add","Array","isArray","result","map","join","delete","keys","Object","sort","k","JSON","stringify","signCanonical","body","secret","ts","Math","floor","Date","now","toString","nonce","randomUUID","payload","mac","createHmac","update","digest","verifyCanonical","sig","maxSkewSec","t","Number","isFinite","abs","expected","timingSafeEqual","Uint8Array","Buffer","from","verifySignature","input","signature","createSignature"],"mappings":"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"}