{"version":3,"sources":["../../src/storage/SqliteStorage.ts"],"sourcesContent":["import type { SecondaryStorage } from './types'\n\n/**\n * Minimal SQLite database interface.\n * Compatible with Node.js 22+ native `node:sqlite` DatabaseSync.\n */\nexport interface SqliteDatabase {\n  exec(sql: string): void\n  prepare(sql: string): SqliteStatement\n}\n\nexport interface SqliteStatement {\n  get(...params: unknown[]): unknown\n  run(...params: unknown[]): { changes: bigint | number }\n}\n\n/**\n * Global key for cleanup interval to survive HMR.\n */\nconst CLEANUP_KEY = '__payloadBetterAuthSqliteCleanup__'\n\ninterface CleanupState {\n  interval: null | ReturnType<typeof setInterval>\n}\n\nfunction getCleanupState(): CleanupState {\n  const g = globalThis as unknown as { [CLEANUP_KEY]?: CleanupState }\n  if (!g[CLEANUP_KEY]) {\n    g[CLEANUP_KEY] = { interval: null }\n  }\n  return g[CLEANUP_KEY]\n}\n\nexport interface SqliteStorageOptions {\n  /**\n   * SQLite database instance from Node.js 22+ native `node:sqlite`.\n   *\n   * @example\n   * import { DatabaseSync } from 'node:sqlite'\n   * const db = new DatabaseSync('.dev-sync-state.db')\n   */\n  db: SqliteDatabase\n}\n\n/**\n * Create a SQLite-backed storage adapter using Node.js 22+ native sqlite.\n *\n * **Note:** This adapter is intended for development and testing only.\n * For staging and production environments, use `createRedisStorage` instead.\n *\n * Suitable for:\n * - Local development (persists across HMR and restarts)\n * - Testing environments\n * - No native bindings to manage - built into Node.js\n *\n * Data is stored on disk and survives process restarts.\n *\n * @example\n * import { DatabaseSync } from 'node:sqlite'\n * import { createSqliteStorage } from 'payload-better-auth/storage'\n *\n * const db = new DatabaseSync('.dev-sync-state.db')\n * const storage = createSqliteStorage({ db })\n */\nexport function createSqliteStorage(options: SqliteStorageOptions): SecondaryStorage {\n  const nodeEnv = process.env.NODE_ENV?.toLowerCase()\n  if (nodeEnv === 'staging' || nodeEnv === 'production') {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `\\n⚠️  [payload-better-auth] WARNING: SqliteStorage is not recommended for ${nodeEnv} environments.\\n` +\n        '   Use createRedisStorage() for distributed/multi-server deployments.\\n',\n    )\n  }\n\n  const { db } = options\n  const cleanupState = getCleanupState()\n\n  // Create table if not exists\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS kv (\n      key TEXT PRIMARY KEY,\n      value TEXT NOT NULL,\n      expires_at INTEGER\n    )\n  `)\n\n  // Prepare statements for better performance\n  const getStmt = db.prepare('SELECT value, expires_at FROM kv WHERE key = ?')\n  const setStmt = db.prepare('INSERT OR REPLACE INTO kv (key, value, expires_at) VALUES (?, ?, ?)')\n  const deleteStmt = db.prepare('DELETE FROM kv WHERE key = ?')\n  const cleanupStmt = db.prepare('DELETE FROM kv WHERE expires_at IS NOT NULL AND expires_at < ?')\n\n  // Start cleanup interval if not already running\n  if (!cleanupState.interval) {\n    cleanupState.interval = setInterval(() => {\n      cleanupStmt.run(Date.now())\n    }, 60_000)\n\n    // Don't prevent Node.js from exiting\n    if (typeof cleanupState.interval.unref === 'function') {\n      cleanupState.interval.unref()\n    }\n  }\n\n  return {\n    delete(key: string): Promise<void> {\n      deleteStmt.run(key)\n      return Promise.resolve()\n    },\n\n    get(key: string): Promise<null | string> {\n      const row = getStmt.get(key) as { expires_at: null | number; value: string } | undefined\n\n      if (!row) {\n        return Promise.resolve(null)\n      }\n\n      // Check expiration\n      if (row.expires_at !== null && row.expires_at < Date.now()) {\n        deleteStmt.run(key)\n        return Promise.resolve(null)\n      }\n\n      return Promise.resolve(row.value)\n    },\n\n    set(key: string, value: string, ttl?: number): Promise<void> {\n      const expiresAt = ttl ? Date.now() + ttl * 1000 : null\n      setStmt.run(key, value, expiresAt)\n      return Promise.resolve()\n    },\n  }\n}\n"],"names":["CLEANUP_KEY","getCleanupState","g","globalThis","interval","createSqliteStorage","options","nodeEnv","process","env","NODE_ENV","toLowerCase","console","warn","db","cleanupState","exec","getStmt","prepare","setStmt","deleteStmt","cleanupStmt","setInterval","run","Date","now","unref","delete","key","Promise","resolve","get","row","expires_at","value","set","ttl","expiresAt"],"mappings":"AAgBA;;CAEC,GACD,MAAMA,cAAc;AAMpB,SAASC;IACP,MAAMC,IAAIC;IACV,IAAI,CAACD,CAAC,CAACF,YAAY,EAAE;QACnBE,CAAC,CAACF,YAAY,GAAG;YAAEI,UAAU;QAAK;IACpC;IACA,OAAOF,CAAC,CAACF,YAAY;AACvB;AAaA;;;;;;;;;;;;;;;;;;;CAmBC,GACD,OAAO,SAASK,oBAAoBC,OAA6B;IAC/D,MAAMC,UAAUC,QAAQC,GAAG,CAACC,QAAQ,EAAEC;IACtC,IAAIJ,YAAY,aAAaA,YAAY,cAAc;QACrD,sCAAsC;QACtCK,QAAQC,IAAI,CACV,CAAC,0EAA0E,EAAEN,QAAQ,gBAAgB,CAAC,GACpG;IAEN;IAEA,MAAM,EAAEO,EAAE,EAAE,GAAGR;IACf,MAAMS,eAAed;IAErB,6BAA6B;IAC7Ba,GAAGE,IAAI,CAAC,CAAC;;;;;;EAMT,CAAC;IAED,4CAA4C;IAC5C,MAAMC,UAAUH,GAAGI,OAAO,CAAC;IAC3B,MAAMC,UAAUL,GAAGI,OAAO,CAAC;IAC3B,MAAME,aAAaN,GAAGI,OAAO,CAAC;IAC9B,MAAMG,cAAcP,GAAGI,OAAO,CAAC;IAE/B,gDAAgD;IAChD,IAAI,CAACH,aAAaX,QAAQ,EAAE;QAC1BW,aAAaX,QAAQ,GAAGkB,YAAY;YAClCD,YAAYE,GAAG,CAACC,KAAKC,GAAG;QAC1B,GAAG;QAEH,qCAAqC;QACrC,IAAI,OAAOV,aAAaX,QAAQ,CAACsB,KAAK,KAAK,YAAY;YACrDX,aAAaX,QAAQ,CAACsB,KAAK;QAC7B;IACF;IAEA,OAAO;QACLC,QAAOC,GAAW;YAChBR,WAAWG,GAAG,CAACK;YACf,OAAOC,QAAQC,OAAO;QACxB;QAEAC,KAAIH,GAAW;YACb,MAAMI,MAAMf,QAAQc,GAAG,CAACH;YAExB,IAAI,CAACI,KAAK;gBACR,OAAOH,QAAQC,OAAO,CAAC;YACzB;YAEA,mBAAmB;YACnB,IAAIE,IAAIC,UAAU,KAAK,QAAQD,IAAIC,UAAU,GAAGT,KAAKC,GAAG,IAAI;gBAC1DL,WAAWG,GAAG,CAACK;gBACf,OAAOC,QAAQC,OAAO,CAAC;YACzB;YAEA,OAAOD,QAAQC,OAAO,CAACE,IAAIE,KAAK;QAClC;QAEAC,KAAIP,GAAW,EAAEM,KAAa,EAAEE,GAAY;YAC1C,MAAMC,YAAYD,MAAMZ,KAAKC,GAAG,KAAKW,MAAM,OAAO;YAClDjB,QAAQI,GAAG,CAACK,KAAKM,OAAOG;YACxB,OAAOR,QAAQC,OAAO;QACxB;IACF;AACF"}