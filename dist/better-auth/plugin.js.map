{"version":3,"sources":["../../src/better-auth/plugin.ts"],"sourcesContent":["// src/plugins/reconcile-queue-plugin.ts\nimport type { AuthContext, BetterAuthPlugin, DeepPartial } from 'better-auth'\nimport type { SanitizedConfig } from 'payload'\n\nimport { APIError } from 'better-auth/api'\nimport { createAuthEndpoint, createAuthMiddleware } from 'better-auth/plugins'\n\nimport type { EventBus } from '../eventBus/types'\nimport type { SecondaryStorage } from '../storage/types'\nimport type { AuthMethod } from './helpers'\n\nimport { createDeduplicatedLogger } from '../shared/deduplicatedLogger'\nimport { SESSION_COOKIE_NAME_KEY, TIMESTAMP_PREFIX } from '../storage/keys'\nimport { type InitOptions, Queue } from './reconcile-queue'\nimport {\n  type BAUser,\n  createDeleteUserFromPayload,\n  createListPayloadUsersPage,\n  createSyncUserToPayload,\n} from './sources'\n\ntype PayloadSyncPluginContext = { payloadSyncPlugin: { queue: Queue } } & AuthContext\n\ntype CreateAdminsUser = Parameters<AuthContext['internalAdapter']['createUser']>['0']\n\nconst defaultLog = (msg: string, extra?: unknown) => {\n  console.log(`[reconcile] ${msg}`, extra ? JSON.stringify(extra, null, 2) : '')\n}\n\nexport interface PayloadBetterAuthPluginOptions extends InitOptions {\n  createAdmins?: { overwrite?: boolean; user: CreateAdminsUser }[]\n  enableLogging?: boolean\n  /**\n   * EventBus for timestamp-based coordination between plugins.\n   * Both plugins MUST share the same eventBus instance.\n   *\n   * Available implementations:\n   * - `createSqlitePollingEventBus()` - Uses SQLite for cross-process coordination\n   *\n   * @example\n   * // Create shared eventBus (e.g., in a separate file)\n   * import { createSqlitePollingEventBus } from 'payload-better-auth'\n   * import { DatabaseSync } from 'node:sqlite'\n   * const db = new DatabaseSync('.event-bus.db')\n   * export const eventBus = createSqlitePollingEventBus({ db })\n   */\n  eventBus: EventBus\n  payloadConfig: Promise<SanitizedConfig>\n  /**\n   * Secondary storage for state coordination between Better Auth and Payload.\n   * Both plugins MUST share the same storage instance.\n   *\n   * This storage is automatically passed to Better Auth as `secondaryStorage`,\n   * enabling session caching - Payload validates sessions directly from storage\n   * without HTTP calls to Better Auth.\n   *\n   * Available storage adapters:\n   * - `createSqliteStorage()` - Uses Node.js 22+ native SQLite (no external dependencies, recommended for dev)\n   * - `createRedisStorage(redis)` - Redis-backed, for distributed/multi-server production\n   *\n   * @example\n   * // Create shared storage (e.g., in a separate file)\n   * import { createSqliteStorage } from 'payload-better-auth'\n   * import { DatabaseSync } from 'node:sqlite'\n   * const db = new DatabaseSync('.sync-state.db')\n   * export const storage = createSqliteStorage({ db })\n   */\n  storage: SecondaryStorage\n  token: string // simple header token for admin endpoints\n}\n\n/**\n * Create database hooks that enqueue user changes to the reconciliation queue.\n * All sync operations go through the queue for consistent handling with retries.\n */\nfunction createQueueBasedHooks(queue: Queue) {\n  return {\n    user: {\n      create: {\n        after: (user: BAUser): Promise<void> => {\n          queue.enqueueEnsure(user, true, 'user-operation')\n          return Promise.resolve()\n        },\n      },\n      delete: {\n        after: (user: BAUser): Promise<void> => {\n          queue.enqueueDelete(user.id, true, 'user-operation')\n          return Promise.resolve()\n        },\n      },\n      update: {\n        after: (user: BAUser): Promise<void> => {\n          queue.enqueueEnsure(user, true, 'user-operation')\n          return Promise.resolve()\n        },\n      },\n    },\n  }\n}\n\nexport const payloadBetterAuthPlugin = (opts: PayloadBetterAuthPluginOptions): BetterAuthPlugin => {\n  const { eventBus, storage } = opts\n\n  // Create deduplicated logger\n  const logger = createDeduplicatedLogger({\n    enabled: opts.enableLogging ?? false,\n    prefix: '[better-auth]',\n    storage,\n  })\n\n  // Keep the simple log for queue operations (they handle their own deduplication)\n  const queueLog = opts.enableLogging ? defaultLog : undefined\n\n  // Track subscription for cleanup\n  let unsubscribeFromPayload: (() => void) | null = null\n\n  return {\n    id: 'reconcile-queue-plugin',\n    endpoints: {\n      run: createAuthEndpoint(\n        '/reconcile/run',\n        { method: 'POST' },\n        async ({ context, json, request }) => {\n          if (opts.token && request?.headers.get('x-reconcile-token') !== opts.token) {\n            throw new APIError('UNAUTHORIZED', { message: 'invalid token' })\n          }\n          await (context as PayloadSyncPluginContext).payloadSyncPlugin.queue.seedFullReconcile()\n          return json({ ok: true })\n        },\n      ),\n      status: createAuthEndpoint(\n        '/reconcile/status',\n        { method: 'GET' },\n        async ({ context, json, request }) => {\n          if (opts.token && request?.headers.get('x-reconcile-token') !== opts.token) {\n            return Promise.reject(\n              new APIError('UNAUTHORIZED', { message: 'invalid token' }) as Error,\n            )\n          }\n          return json((context as PayloadSyncPluginContext).payloadSyncPlugin.queue.status())\n        },\n      ),\n      // convenience for tests/admin tools (optional)\n      authMethods: createAuthEndpoint(\n        '/auth/methods',\n        { method: 'GET' },\n        async ({ context, json }) => {\n          const authMethods: AuthMethod[] = []\n          // Check if emailAndPassword is enabled, or if present at all (not present defaults to false)\n          if (context.options.emailAndPassword?.enabled) {\n            authMethods.push({\n              method: 'emailAndPassword',\n              options: {\n                minPasswordLength: context.options.emailAndPassword.minPasswordLength ?? 0,\n              },\n            })\n          }\n          if (context.options.plugins?.some((p) => p.id === 'magic-link')) {\n            authMethods.push({ method: 'magicLink' })\n          }\n\n          return await json(authMethods)\n        },\n      ),\n      deleteNow: createAuthEndpoint(\n        '/reconcile/delete',\n        { method: 'POST' },\n        async ({ context, json, request }) => {\n          if (opts.token && request?.headers.get('x-reconcile-token') !== opts.token) {\n            throw new APIError('UNAUTHORIZED', { message: 'invalid token' })\n          }\n          const body = (await request?.json().catch(() => ({}))) as { baId?: string } | undefined\n          const baId = body?.baId\n          if (!baId) {\n            throw new APIError('BAD_REQUEST', { message: 'missing baId' })\n          }\n          ;(context as PayloadSyncPluginContext).payloadSyncPlugin.queue.enqueueDelete(\n            baId,\n            true,\n            'user-operation',\n          )\n          return json({ ok: true })\n        },\n      ),\n      ensureNow: createAuthEndpoint(\n        '/reconcile/ensure',\n        { method: 'POST' },\n        async ({ context, json, request }) => {\n          if (opts.token && request?.headers.get('x-reconcile-token') !== opts.token) {\n            throw new APIError('UNAUTHORIZED', { message: 'invalid token' })\n          }\n          const body = (await request?.json().catch(() => ({}))) as { user?: BAUser } | undefined\n          const user = body?.user\n          if (!user?.id) {\n            throw new APIError('BAD_REQUEST', { message: 'missing user' })\n          }\n          ;(context as PayloadSyncPluginContext).payloadSyncPlugin.queue.enqueueEnsure(\n            user,\n            true,\n            'user-operation',\n          )\n          return json({ ok: true })\n        },\n      ),\n    },\n    hooks: {\n      before: [\n        {\n          handler: createAuthMiddleware(async (ctx) => {\n            const locale = ctx.getHeader('User-Locale')\n            return Promise.resolve({\n              context: { ...ctx, body: { ...ctx.body, locale: locale ?? undefined } },\n            })\n          }),\n          matcher: (context) => {\n            return context.path === '/sign-up/email'\n          },\n        },\n      ],\n    },\n    async init({ internalAdapter, options, password }) {\n      // Compute and store the session cookie name for Payload to read\n      // This accounts for cookiePrefix, custom cookie names, and __Secure- prefix\n      const cookiePrefix = options.advanced?.cookiePrefix ?? 'better-auth'\n      const customCookieName = options.advanced?.cookies?.session_token?.name\n      // Better Auth uses secure cookies when:\n      // 1. Explicitly set via useSecureCookies option\n      // 2. NODE_ENV is 'production'\n      // 3. baseURL starts with 'https://'\n      const isHttps = options.baseURL?.startsWith('https://') ?? false\n      const useSecureCookies =\n        options.advanced?.useSecureCookies ?? (process.env.NODE_ENV === 'production' || isHttps)\n\n      let sessionCookieName: string\n      if (customCookieName) {\n        // Custom cookie name takes precedence\n        sessionCookieName = useSecureCookies ? `__Secure-${customCookieName}` : customCookieName\n      } else {\n        // Default format: {prefix}.session_token\n        const baseName = `${cookiePrefix}.session_token`\n        sessionCookieName = useSecureCookies ? `__Secure-${baseName}` : baseName\n      }\n\n      // Store session cookie name in KV for Payload plugin to read\n      await storage.set(SESSION_COOKIE_NAME_KEY, sessionCookieName)\n      await logger.log('cookie-config', `Session cookie name: ${sessionCookieName}`)\n\n      // Create admin users if configured\n      if (opts.createAdmins) {\n        try {\n          await Promise.all(\n            opts.createAdmins.map(async ({ overwrite, user }) => {\n              const alreadyExistingUser = await internalAdapter.findUserByEmail(user.email)\n              if (alreadyExistingUser) {\n                if (overwrite) {\n                  // clear accounts\n                  await internalAdapter.deleteAccounts(alreadyExistingUser.user.id)\n                  const createdUser = await internalAdapter.updateUser(\n                    alreadyExistingUser.user.id,\n                    {\n                      ...user,\n                      role: 'admin',\n                    },\n                  )\n                  await internalAdapter.linkAccount({\n                    accountId: createdUser.id,\n                    password: await password.hash(user.password),\n                    providerId: 'credential',\n                    userId: createdUser.id,\n                  })\n                }\n              } else {\n                const createdUser = await internalAdapter.createUser({ ...user, role: 'admin' })\n                await internalAdapter.linkAccount({\n                  accountId: createdUser.id,\n                  password: await password.hash(user.password),\n                  providerId: 'credential',\n                  userId: createdUser.id,\n                })\n              }\n            }),\n          )\n        } catch (error) {\n          logger.always('Failed to create Admin user', error)\n        }\n      }\n\n      // Create the reconciliation queue\n      const queue = new Queue(\n        {\n          deleteUserFromPayload: createDeleteUserFromPayload(opts.payloadConfig),\n          internalAdapter,\n          listPayloadUsersPage: createListPayloadUsersPage(opts.payloadConfig),\n          log: queueLog,\n          syncUserToPayload: createSyncUserToPayload(opts.payloadConfig),\n        },\n        {\n          ...opts,\n          // Don't run reconcile on boot - we use timestamp-based coordination instead\n          runOnBoot: false,\n        },\n      )\n\n      // Log init (deduplicated)\n      await logger.log('init', 'Initialized')\n\n      // Timestamp-based reconciliation coordination\n      async function attemptReconciliation(): Promise<void> {\n        logger.always('Syncing users to Payload...')\n        await storage.set(TIMESTAMP_PREFIX + 'better-auth', String(Date.now()))\n        try {\n          await queue.seedFullReconcile()\n          logger.always('Sync completed successfully')\n          // Success - unsubscribe if we were watching\n          if (unsubscribeFromPayload) {\n            unsubscribeFromPayload()\n            unsubscribeFromPayload = null\n          }\n        } catch (error) {\n          logger.always('Sync failed, will retry when Payload restarts', error)\n          // Subscribe to Payload timestamp changes if not already\n          if (!unsubscribeFromPayload) {\n            unsubscribeFromPayload = eventBus.subscribeToTimestamp('payload', () => {\n              attemptReconciliation().catch((err) => {\n                logger.always('Sync attempt failed', err)\n              })\n            })\n          }\n        }\n      }\n\n      // Check if Payload is online and started more recently than our last reconcile\n      const payloadTsStr = await storage.get(TIMESTAMP_PREFIX + 'payload')\n      const baTsStr = await storage.get(TIMESTAMP_PREFIX + 'better-auth')\n      const payloadTs = payloadTsStr ? parseInt(payloadTsStr, 10) : null\n      const baTs = baTsStr ? parseInt(baTsStr, 10) : null\n\n      // Determine reconciliation state\n      if (payloadTs === null) {\n        // Payload hasn't started yet\n        await logger.log('status', 'Waiting for Payload to start...')\n        unsubscribeFromPayload = eventBus.subscribeToTimestamp('payload', () => {\n          attemptReconciliation().catch((err) => {\n            logger.always('Sync attempt failed', err)\n          })\n        })\n      } else if (baTs === null) {\n        // First run - always sync\n        attemptReconciliation().catch((err) => {\n          logger.always('Initial sync failed', err)\n        })\n      } else if (payloadTs > baTs) {\n        // Payload restarted since last reconcile - sync needed\n        attemptReconciliation().catch((err) => {\n          logger.always('Sync failed', err)\n        })\n      } else {\n        // Already reconciled and up-to-date\n        await logger.log('status', 'Already synchronized', {\n          lastSync: new Date(baTs).toISOString(),\n        })\n        unsubscribeFromPayload = eventBus.subscribeToTimestamp('payload', () => {\n          attemptReconciliation().catch((err) => {\n            logger.always('Sync attempt failed', err)\n          })\n        })\n      }\n\n      // Create queue-based database hooks - all user sync goes through the queue\n      const queueBasedHooks = createQueueBasedHooks(queue)\n\n      return {\n        context: { payloadSyncPlugin: { queue } } as DeepPartial<Omit<AuthContext, 'options'>>,\n        options: {\n          databaseHooks: queueBasedHooks,\n          // Pass storage to Better Auth as secondaryStorage - this makes BA write sessions\n          // to the shared storage, allowing Payload to validate sessions directly from cache\n          secondaryStorage: storage,\n          user: { deleteUser: { enabled: true } },\n        },\n      }\n    },\n    schema: {\n      user: {\n        fields: {\n          locale: {\n            type: 'string',\n            required: false,\n          },\n        },\n      },\n    },\n  }\n}\n"],"names":["APIError","createAuthEndpoint","createAuthMiddleware","createDeduplicatedLogger","SESSION_COOKIE_NAME_KEY","TIMESTAMP_PREFIX","Queue","createDeleteUserFromPayload","createListPayloadUsersPage","createSyncUserToPayload","defaultLog","msg","extra","console","log","JSON","stringify","createQueueBasedHooks","queue","user","create","after","enqueueEnsure","Promise","resolve","delete","enqueueDelete","id","update","payloadBetterAuthPlugin","opts","eventBus","storage","logger","enabled","enableLogging","prefix","queueLog","undefined","unsubscribeFromPayload","endpoints","run","method","context","json","request","token","headers","get","message","payloadSyncPlugin","seedFullReconcile","ok","status","reject","authMethods","options","emailAndPassword","push","minPasswordLength","plugins","some","p","deleteNow","body","catch","baId","ensureNow","hooks","before","handler","ctx","locale","getHeader","matcher","path","init","internalAdapter","password","cookiePrefix","advanced","customCookieName","cookies","session_token","name","isHttps","baseURL","startsWith","useSecureCookies","process","env","NODE_ENV","sessionCookieName","baseName","set","createAdmins","all","map","overwrite","alreadyExistingUser","findUserByEmail","email","deleteAccounts","createdUser","updateUser","role","linkAccount","accountId","hash","providerId","userId","createUser","error","always","deleteUserFromPayload","payloadConfig","listPayloadUsersPage","syncUserToPayload","runOnBoot","attemptReconciliation","String","Date","now","subscribeToTimestamp","err","payloadTsStr","baTsStr","payloadTs","parseInt","baTs","lastSync","toISOString","queueBasedHooks","databaseHooks","secondaryStorage","deleteUser","schema","fields","type","required"],"mappings":"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"}