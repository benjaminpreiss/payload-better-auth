{"version":3,"sources":["../../src/better-auth/sources.ts"],"sourcesContent":["// src/sources.ts\nimport { type CollectionSlug, getPayload, type SanitizedConfig } from 'payload'\n\nimport { signCanonical } from './crypto-shared'\n\nconst INTERNAL_SECRET = process.env.BA_TO_PAYLOAD_SECRET!\n\nexport type BAUser = { [k: string]: unknown; email?: null | string; id: string }\nexport type PayloadUser = { baUserId?: null | string; id: number | string }\n\n// Better Auth user type for sync operations\nexport interface BetterAuthUser {\n  [k: string]: unknown\n  email?: null | string\n  emailVerified?: boolean\n  id: string\n  name?: null | string\n}\n\n// Better Auth account type\nexport interface BetterAuthAccount {\n  accountId: string\n  createdAt: Date\n  id: string\n  providerId: string\n  updatedAt: Date\n  userId: string\n}\n\n// ═══════════════════════════════════════════════════════════════════════════\n// Payload Operations\n// ═══════════════════════════════════════════════════════════════════════════\n\n/** Create a function to load Payload users page by page via Local API. */\nexport function createListPayloadUsersPage<TCollectionSlug extends string>(\n  config: Promise<SanitizedConfig>,\n  usersSlug: TCollectionSlug,\n) {\n  return async function listPayloadUsersPage(\n    limit: number,\n    page: number,\n  ): Promise<{ hasNextPage: boolean; total: number; users: PayloadUser[] }> {\n    const payload = await getPayload({ config })\n    const res = await payload.find({\n      collection: usersSlug as CollectionSlug,\n      depth: 0,\n      limit,\n      overrideAccess: true,\n      page,\n    })\n    return {\n      hasNextPage: res.hasNextPage || false,\n      total: res.totalDocs || 0,\n      users: res.docs.map((d) => ({\n        id: d.id,\n        baUserId: (d as { baUserId?: string }).baUserId,\n      })),\n    }\n  }\n}\n\n/**\n * Create a function to sync user from better-auth to Payload.\n * This handles creating/updating both BA collection entries and the user.\n */\nexport function createSyncUserToPayload<TUser extends object, TCollectionSlug extends string>(\n  config: Promise<SanitizedConfig>,\n  emailPasswordSlug: TCollectionSlug,\n  magicLinkSlug: TCollectionSlug,\n  usersSlug: TCollectionSlug,\n  mapUserToPayload: (\n    baUser: BetterAuthUser,\n  ) => Omit<TUser, 'baUserId' | 'betterAuthAccounts' | 'createdAt' | 'id' | 'updatedAt'>,\n) {\n  return async function syncUserToPayload(\n    betterAuthUser: BetterAuthUser,\n    accounts?: BetterAuthAccount[],\n  ) {\n    const payload = await getPayload({ config })\n\n    // Map BA user to Payload user data using the callback\n    const userData = mapUserToPayload(betterAuthUser)\n\n    // Check if user already exists\n    const existing = await payload.find({\n      collection: usersSlug as CollectionSlug,\n      limit: 1,\n      where: { baUserId: { equals: betterAuthUser.id } },\n    })\n\n    // Track relationship IDs\n    let emailPasswordAccountId: null | number | string = null\n    let magicLinkAccountId: null | number | string = null\n\n    // Check if there's a credential (email/password) account\n    const hasCredentialAccount = accounts?.some((a) => a.providerId === 'credential')\n\n    // Sync BA collection entries for each account\n    if (accounts) {\n      for (const account of accounts) {\n        if (account.providerId === 'credential') {\n          // Email/password account\n          const existingBA = await payload.find({\n            collection: emailPasswordSlug as CollectionSlug,\n            limit: 1,\n            where: { baAccountId: { equals: account.id } },\n          })\n\n          const baData = {\n            baAccountId: account.id,\n            baUserId: betterAuthUser.id,\n            email: betterAuthUser.email ?? '',\n            emailVerified: betterAuthUser.emailVerified ?? false,\n          }\n\n          if (existingBA.docs.length) {\n            // Update existing\n            const baBody = { accountId: account.id, collection: emailPasswordSlug, op: 'update' }\n            const baSig = signCanonical(baBody, INTERNAL_SECRET)\n\n            const updated = await payload.update({\n              id: existingBA.docs[0].id,\n              collection: emailPasswordSlug as CollectionSlug,\n              context: { baBody, baSig },\n              data: baData,\n              overrideAccess: false,\n            })\n            emailPasswordAccountId = updated.id\n          } else {\n            // Create new\n            const baBody = { accountId: account.id, collection: emailPasswordSlug, op: 'create' }\n            const baSig = signCanonical(baBody, INTERNAL_SECRET)\n\n            const created = await payload.create({\n              collection: emailPasswordSlug as CollectionSlug,\n              context: { baBody, baSig },\n              data: baData,\n              overrideAccess: false,\n            })\n            emailPasswordAccountId = created.id\n          }\n        }\n        // Note: Better Auth's magic-link plugin does NOT create account entries,\n        // so we handle magic-link detection separately below\n      }\n    }\n\n    // Magic-link detection: If user is email-verified but has no credential account,\n    // they likely authenticated via magic-link. Better Auth's magic-link plugin\n    // doesn't create account entries - it only verifies the user's email.\n    if (betterAuthUser.emailVerified && !hasCredentialAccount && betterAuthUser.email) {\n      // Use a synthetic account ID based on user ID for magic-link\n      const syntheticAccountId = `magic-link:${betterAuthUser.id}`\n\n      const existingBA = await payload.find({\n        collection: magicLinkSlug as CollectionSlug,\n        limit: 1,\n        where: { baAccountId: { equals: syntheticAccountId } },\n      })\n\n      const baData = {\n        baAccountId: syntheticAccountId,\n        baUserId: betterAuthUser.id,\n        email: betterAuthUser.email,\n        emailVerified: true,\n      }\n\n      if (existingBA.docs.length) {\n        // Update existing\n        const baBody = { accountId: syntheticAccountId, collection: magicLinkSlug, op: 'update' }\n        const baSig = signCanonical(baBody, INTERNAL_SECRET)\n\n        const updated = await payload.update({\n          id: existingBA.docs[0].id,\n          collection: magicLinkSlug as CollectionSlug,\n          context: { baBody, baSig },\n          data: baData,\n          overrideAccess: false,\n        })\n        magicLinkAccountId = updated.id\n      } else {\n        // Create new\n        const baBody = { accountId: syntheticAccountId, collection: magicLinkSlug, op: 'create' }\n        const baSig = signCanonical(baBody, INTERNAL_SECRET)\n\n        const created = await payload.create({\n          collection: magicLinkSlug as CollectionSlug,\n          context: { baBody, baSig },\n          data: baData,\n          overrideAccess: false,\n        })\n        magicLinkAccountId = created.id\n      }\n    }\n\n    // Build polymorphic relationship array for betterAuthAccounts\n    // Format: { relationTo: 'collection_slug', value: id }\n    const betterAuthAccounts: Array<{ relationTo: string; value: number | string }> = []\n    if (emailPasswordAccountId !== null) {\n      betterAuthAccounts.push({ relationTo: emailPasswordSlug, value: emailPasswordAccountId })\n    }\n    if (magicLinkAccountId !== null) {\n      betterAuthAccounts.push({ relationTo: magicLinkSlug, value: magicLinkAccountId })\n    }\n\n    // Build user data with relationships\n    const fullUserData = {\n      ...userData,\n      baUserId: betterAuthUser.id,\n      ...(betterAuthAccounts.length > 0 && { betterAuthAccounts }),\n    }\n\n    if (existing.docs.length) {\n      // Update existing user (re-apply mapUserToPayload for schema changes)\n      const baBody = { collection: usersSlug, op: 'update', userId: betterAuthUser.id }\n      const baSig = signCanonical(baBody, INTERNAL_SECRET)\n\n      await payload.update({\n        id: existing.docs[0].id,\n        collection: usersSlug as CollectionSlug,\n        context: { baBody, baSig },\n        data: fullUserData,\n        overrideAccess: false,\n      })\n    } else {\n      // Create new user\n      const baBody = { collection: usersSlug, op: 'create', userId: betterAuthUser.id }\n      const baSig = signCanonical(baBody, INTERNAL_SECRET)\n\n      await payload.create({\n        collection: usersSlug as CollectionSlug,\n        context: { baBody, baSig },\n        data: fullUserData,\n        overrideAccess: false,\n      })\n    }\n  }\n}\n\n/** Create a function to delete user from Payload, including BA collection entries. */\nexport function createDeleteUserFromPayload<TCollectionSlug extends string>(\n  config: Promise<SanitizedConfig>,\n  emailPasswordSlug: TCollectionSlug,\n  magicLinkSlug: TCollectionSlug,\n  usersSlug: TCollectionSlug,\n) {\n  return async function deleteUserFromPayload(betterAuthUserId: string) {\n    const payload = await getPayload({ config })\n\n    // Find user\n    const existing = await payload.find({\n      collection: usersSlug as CollectionSlug,\n      limit: 1,\n      where: { baUserId: { equals: betterAuthUserId } },\n    })\n    if (!existing.docs.length) {\n      return\n    }\n\n    const userId = existing.docs[0].id\n\n    // Delete BA collection entries first\n    const emailPasswordEntries = await payload.find({\n      collection: emailPasswordSlug as CollectionSlug,\n      limit: 100,\n      where: { baUserId: { equals: betterAuthUserId } },\n    })\n\n    for (const entry of emailPasswordEntries.docs) {\n      const accountId = (entry as unknown as { baAccountId: string }).baAccountId\n      const baBody = { accountId, collection: emailPasswordSlug, op: 'delete' }\n      const baSig = signCanonical(baBody, INTERNAL_SECRET)\n\n      await payload.delete({\n        id: entry.id,\n        collection: emailPasswordSlug as CollectionSlug,\n        context: { baBody, baSig },\n        overrideAccess: false,\n      })\n    }\n\n    const magicLinkEntries = await payload.find({\n      collection: magicLinkSlug as CollectionSlug,\n      limit: 100,\n      where: { baUserId: { equals: betterAuthUserId } },\n    })\n\n    for (const entry of magicLinkEntries.docs) {\n      const accountId = (entry as unknown as { baAccountId: string }).baAccountId\n      const baBody = { accountId, collection: magicLinkSlug, op: 'delete' }\n      const baSig = signCanonical(baBody, INTERNAL_SECRET)\n\n      await payload.delete({\n        id: entry.id,\n        collection: magicLinkSlug as CollectionSlug,\n        context: { baBody, baSig },\n        overrideAccess: false,\n      })\n    }\n\n    // Delete the user\n    const baBody = { collection: usersSlug, op: 'delete', userId: betterAuthUserId }\n    const baSig = signCanonical(baBody, INTERNAL_SECRET)\n\n    await payload.delete({\n      id: userId,\n      collection: usersSlug as CollectionSlug,\n      context: { baBody, baSig },\n      overrideAccess: false,\n    })\n  }\n}\n"],"names":["getPayload","signCanonical","INTERNAL_SECRET","process","env","BA_TO_PAYLOAD_SECRET","createListPayloadUsersPage","config","usersSlug","listPayloadUsersPage","limit","page","payload","res","find","collection","depth","overrideAccess","hasNextPage","total","totalDocs","users","docs","map","d","id","baUserId","createSyncUserToPayload","emailPasswordSlug","magicLinkSlug","mapUserToPayload","syncUserToPayload","betterAuthUser","accounts","userData","existing","where","equals","emailPasswordAccountId","magicLinkAccountId","hasCredentialAccount","some","a","providerId","account","existingBA","baAccountId","baData","email","emailVerified","length","baBody","accountId","op","baSig","updated","update","context","data","created","create","syntheticAccountId","betterAuthAccounts","push","relationTo","value","fullUserData","userId","createDeleteUserFromPayload","deleteUserFromPayload","betterAuthUserId","emailPasswordEntries","entry","delete","magicLinkEntries"],"mappings":"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"}