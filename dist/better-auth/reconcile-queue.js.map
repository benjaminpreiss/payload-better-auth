{"version":3,"sources":["../../src/better-auth/reconcile-queue.ts"],"sourcesContent":["import type { AuthContext } from 'better-auth'\n\n// src/reconcile-queue.ts\nimport type { BAUser, BetterAuthAccount, BetterAuthUser, PayloadUser } from './sources'\n\nexport interface QueueDeps {\n  /** Prefix for Better Auth collections */\n  collectionPrefix: string\n\n  /** Delete user and associated BA collection entries from Payload */\n  deleteUserFromPayload: (baId: string) => Promise<void>\n\n  /** Better Auth internal adapter for fetching users and accounts */\n  internalAdapter: AuthContext['internalAdapter']\n\n  // Paginated loaders (efficient processing)\n  listPayloadUsersPage: (\n    limit: number,\n    page: number,\n  ) => Promise<{ hasNextPage: boolean; total: number; users: PayloadUser[] }>\n\n  // Logging\n  log?: (msg: string, extra?: unknown) => void\n\n  /** Map BA user to Payload user data */\n  mapUserToPayload: (baUser: BetterAuthUser) => Record<string, unknown>\n\n  // Policy\n  prunePayloadOrphans?: boolean // default: false\n\n  /** Sync user and BA collection entries to Payload */\n  syncUserToPayload: (baUser: BAUser, accounts?: BetterAuthAccount[]) => Promise<void>\n}\n\nexport type TaskSource = 'full-reconcile' | 'user-operation'\n\n// Bootstrap options interface\nexport interface InitOptions {\n  forceReset?: boolean\n  reconcileEveryMs?: number\n  runOnBoot?: boolean\n  tickMs?: number\n}\n\ntype Task =\n  | {\n      attempts: number\n      baId: string\n      baUser?: BAUser\n      kind: 'ensure'\n      nextAt: number\n      reconcileId?: string\n      source: TaskSource\n    }\n  | {\n      attempts: number\n      baId: string\n      kind: 'delete'\n      nextAt: number\n      reconcileId?: string\n      source: TaskSource\n    }\n\nconst KEY = (t: Task) => `${t.kind}:${t.baId}`\n\nexport class Queue {\n  private deps!: QueueDeps\n  private failed = 0\n  private keys = new Map<string, Task>()\n  private lastError: null | string = null\n  private lastSeedAt: null | string = null\n  private processed = 0\n\n  private processing = false\n  private q: Task[] = []\n  private reconcileEveryMs = 30 * 60_000 // default 30 minutes\n  private reconcileTimeout: NodeJS.Timeout | null = null\n  private reconciling = false\n\n  private tickTimer: NodeJS.Timeout | null = null\n\n  constructor(deps: QueueDeps, opts: InitOptions = {}) {\n    this.deps = deps\n\n    // Start timers but don't run reconcile immediately\n    this.start({\n      reconcileEveryMs: opts?.reconcileEveryMs ?? 30 * 60_000,\n      tickMs: opts?.tickMs ?? 1000,\n    })\n\n    // Defer the initial reconcile to avoid circular dependency issues\n    if (opts?.runOnBoot ?? true) {\n      // Use setTimeout instead of queueMicrotask to give more time for initialization\n      setTimeout(() => {\n        this.seedFullReconcile().catch(\n          (err) => this.deps.log && this.deps.log('[reconcile] seed failed', err),\n        )\n      }, 2000) // 2 second delay to allow Better Auth and Payload to fully initialize\n    }\n  }\n\n  private bumpFront(task: Task) {\n    this.q = [task, ...this.q.filter((t) => t !== task)]\n  }\n\n  /** Clear all full-reconcile tasks from the queue, preserving user-operation tasks */\n  private clearFullReconcileTasks() {\n    const log = this.deps?.log ?? (() => {})\n    const beforeCount = this.q.length\n    const fullReconcileCount = this.q.filter((t) => t.source === 'full-reconcile').length\n\n    // Remove full-reconcile tasks from queue and keys map\n    this.q = this.q.filter((task) => {\n      if (task.source === 'full-reconcile') {\n        this.keys.delete(KEY(task))\n        return false\n      }\n      return true\n    })\n\n    const afterCount = this.q.length\n    log('reconcile.clear-previous', {\n      afterCount,\n      beforeCount,\n      clearedFullReconcile: fullReconcileCount,\n      preservedUserOps: afterCount,\n    })\n  }\n\n  // ——— Internals ———\n  private enqueue(task: Task, priority: boolean) {\n    const k = KEY(task)\n    const existing = this.keys.get(k)\n    if (existing) {\n      if (task.kind === 'ensure' && existing.kind === 'ensure' && !existing.baUser && task.baUser) {\n        existing.baUser = task.baUser\n      }\n      if (priority) {\n        this.bumpFront(existing)\n      }\n      return\n    }\n    if (priority) {\n      this.q.unshift(task)\n    } else {\n      this.q.push(task)\n    }\n    this.keys.set(k, task)\n  }\n\n  private async listBAUsersPage({ limit, offset }: { limit: number; offset: number }) {\n    // sort by newest (used) first\n    // when a delete is happening in the meantime, this will lead to some users not being listed (as the index changes)\n    // TODO: fix this by maintaining a delete list.\n    const total = await this.deps.internalAdapter.countTotalUsers()\n    const users = await this.deps.internalAdapter.listUsers(limit, offset, {\n      direction: 'desc',\n      field: 'updatedAt',\n    })\n    return { total, users }\n  }\n\n  private async runTask(t: Task) {\n    const log = this.deps?.log ?? (() => {})\n    if (t.kind === 'ensure') {\n      log('queue.ensure', { attempts: t.attempts, baId: t.baId })\n\n      // Get user data (either from task or fetch from BA)\n      const baUser = t.baUser ?? { id: t.baId }\n\n      // Fetch accounts from Better Auth for this user\n      const accounts = await this.deps.internalAdapter.findAccounts(t.baId)\n\n      // Debug: log what accounts were found\n      log('queue.ensure.accounts', {\n        accountCount: accounts?.length ?? 0,\n        accounts: accounts?.map((a) => ({ id: a.id, providerId: a.providerId })),\n        baId: t.baId,\n      })\n\n      // Sync user with accounts to Payload\n      await this.deps.syncUserToPayload(baUser, accounts as BetterAuthAccount[])\n      return\n    }\n    // delete\n    log('queue.delete', { attempts: t.attempts, baId: t.baId })\n    await this.deps.deleteUserFromPayload(t.baId)\n  }\n  private scheduleNextReconcile() {\n    if (this.reconcileTimeout) {\n      clearTimeout(this.reconcileTimeout)\n    }\n\n    this.reconcileTimeout = setTimeout(async () => {\n      if (!this.reconciling) {\n        this.reconciling = true\n        try {\n          await this.seedFullReconcile()\n        } catch (_error) {\n          // Error is already logged in seedFullReconcile\n        } finally {\n          this.reconciling = false\n          // Schedule the next reconcile after this one completes\n          this.scheduleNextReconcile()\n        }\n      }\n    }, this.reconcileEveryMs)\n\n    // Optional unref for Node.js environments to prevent keeping process alive\n    if ('unref' in this.reconcileTimeout && typeof this.reconcileTimeout.unref === 'function') {\n      this.reconcileTimeout.unref()\n    }\n  }\n\n  /** Paginated approach: process users page by page to reduce memory usage */\n  private async seedFullReconcilePaginated(reconcileId: string) {\n    const log = this.deps?.log ?? (() => {})\n    const pageSize = 500\n    let baIdSet: null | Set<string> = null\n\n    // If we need to prune orphans, we need to collect all BA user IDs\n    if (this.deps.prunePayloadOrphans) {\n      baIdSet = new Set<string>()\n      let baOffset = 0\n      let baTotal = 0\n\n      do {\n        const { total, users: baUsers } = await this.listBAUsersPage({\n          limit: pageSize,\n          offset: baOffset,\n        })\n        baTotal = total\n\n        // Enqueue ensure tasks for this page with full-reconcile source\n        for (const u of baUsers) {\n          this.enqueueEnsure(u, false, 'full-reconcile', reconcileId)\n          baIdSet.add(u.id)\n        }\n\n        baOffset += baUsers.length\n        log('reconcile.seed.ba-page', { processed: baOffset, reconcileId, total: baTotal })\n      } while (baOffset < baTotal)\n    } else {\n      // If not pruning, we can process BA users page by page without storing IDs\n      let baOffset = 0\n      let baTotal = 0\n\n      do {\n        // TODO: make sure that we dont go past the window through deletes happening\n        // (As a user deletes, the total window size becomes smaller)\n        const { total, users: baUsers } = await this.listBAUsersPage({\n          limit: pageSize,\n          offset: baOffset,\n        })\n        baTotal = total\n\n        // Enqueue ensure tasks for this page with full-reconcile source\n        for (const u of baUsers) {\n          this.enqueueEnsure(u, false, 'full-reconcile', reconcileId)\n        }\n\n        baOffset += baUsers.length\n        log('reconcile.seed.ba-page', { processed: baOffset, reconcileId, total: baTotal })\n      } while (baOffset < baTotal)\n    }\n\n    // Process Payload users page by page for orphan pruning\n    if (this.deps.prunePayloadOrphans && baIdSet) {\n      let payloadPage = 1\n      let hasNextPage = true\n\n      while (hasNextPage) {\n        const { hasNextPage: nextPage, users: pUsers } = await this.deps.listPayloadUsersPage(\n          pageSize,\n          payloadPage,\n        )\n        hasNextPage = nextPage\n\n        for (const pu of pUsers) {\n          const baId = pu.baUserId?.toString()\n          if (baId && !baIdSet.has(baId)) {\n            this.enqueueDelete(baId, false, 'full-reconcile', reconcileId)\n          }\n        }\n\n        payloadPage++\n        log('reconcile.seed.payload-page', { page: payloadPage - 1, reconcileId })\n      }\n    }\n  }\n\n  private async tick() {\n    if (this.processing) {\n      return\n    }\n    const now = Date.now()\n    const idx = this.q.findIndex((t) => t.nextAt <= now)\n    if (idx === -1) {\n      return\n    }\n    const task = this.q[idx]\n    this.processing = true\n    try {\n      await this.runTask(task)\n      this.q.splice(idx, 1)\n      this.keys.delete(KEY(task))\n      this.processed++\n    } catch (e: unknown) {\n      this.failed++\n      this.lastError = e instanceof Error ? e.message : String(e)\n      task.attempts += 1\n      const delay =\n        Math.min(60_000, Math.pow(2, task.attempts) * 1000) + Math.floor(Math.random() * 500)\n      task.nextAt = now + delay\n    } finally {\n      this.processing = false\n    }\n  }\n\n  enqueueDelete(\n    baId: string,\n    priority = false,\n    source: TaskSource = 'user-operation',\n    reconcileId?: string,\n  ) {\n    this.enqueue(\n      { attempts: 0, baId, kind: 'delete', nextAt: Date.now(), reconcileId, source },\n      priority,\n    )\n  }\n\n  // ——— Public enqueue API ———\n  enqueueEnsure(\n    user: BAUser,\n    priority = false,\n    source: TaskSource = 'user-operation',\n    reconcileId?: string,\n  ) {\n    this.enqueue(\n      {\n        attempts: 0,\n        baId: user.id,\n        baUser: user,\n        kind: 'ensure',\n        nextAt: Date.now(),\n        reconcileId,\n        source,\n      },\n      priority,\n    )\n  }\n\n  /** Seed tasks by comparing users page by page (Better-Auth → Payload). */\n  async seedFullReconcile() {\n    const log = this.deps?.log ?? (() => {})\n    this.lastSeedAt = new Date().toISOString()\n    const reconcileId = `reconcile-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n\n    log('reconcile.seed.start', { reconcileId })\n\n    // Clear all previous full-reconcile tasks, but preserve user-operation tasks\n    this.clearFullReconcileTasks()\n\n    await this.seedFullReconcilePaginated(reconcileId)\n\n    log('reconcile.seed.done', this.status())\n  }\n\n  start({ reconcileEveryMs = 30 * 60_000, tickMs = 1000 } = {}) {\n    this.reconcileEveryMs = reconcileEveryMs\n\n    if (!this.tickTimer) {\n      this.tickTimer = setInterval(() => this.tick(), tickMs)\n      // Optional unref for Node.js environments to prevent keeping process alive\n      if ('unref' in this.tickTimer && typeof this.tickTimer.unref === 'function') {\n        this.tickTimer.unref()\n      }\n    }\n\n    // Schedule the first reconcile\n    this.scheduleNextReconcile()\n  }\n\n  status() {\n    const userOpCount = this.q.filter((t) => t.source === 'user-operation').length\n    const fullReconcileCount = this.q.filter((t) => t.source === 'full-reconcile').length\n\n    return {\n      failed: this.failed,\n      fullReconcileTasks: fullReconcileCount,\n      lastError: this.lastError,\n      lastSeedAt: this.lastSeedAt,\n      processed: this.processed,\n      processing: this.processing,\n      queueSize: this.q.length,\n      reconciling: this.reconciling,\n      sampleKeys: Array.from(this.keys.keys()).slice(0, 50),\n      userOperationTasks: userOpCount,\n    }\n  }\n}\n"],"names":["KEY","t","kind","baId","Queue","deps","failed","keys","Map","lastError","lastSeedAt","processed","processing","q","reconcileEveryMs","reconcileTimeout","reconciling","tickTimer","opts","start","tickMs","runOnBoot","setTimeout","seedFullReconcile","catch","err","log","bumpFront","task","filter","clearFullReconcileTasks","beforeCount","length","fullReconcileCount","source","delete","afterCount","clearedFullReconcile","preservedUserOps","enqueue","priority","k","existing","get","baUser","unshift","push","set","listBAUsersPage","limit","offset","total","internalAdapter","countTotalUsers","users","listUsers","direction","field","runTask","attempts","id","accounts","findAccounts","accountCount","map","a","providerId","syncUserToPayload","deleteUserFromPayload","scheduleNextReconcile","clearTimeout","_error","unref","seedFullReconcilePaginated","reconcileId","pageSize","baIdSet","prunePayloadOrphans","Set","baOffset","baTotal","baUsers","u","enqueueEnsure","add","payloadPage","hasNextPage","nextPage","pUsers","listPayloadUsersPage","pu","baUserId","toString","has","enqueueDelete","page","tick","now","Date","idx","findIndex","nextAt","splice","e","Error","message","String","delay","Math","min","pow","floor","random","user","toISOString","substr","status","setInterval","userOpCount","fullReconcileTasks","queueSize","sampleKeys","Array","from","slice","userOperationTasks"],"mappings":"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"}