{"version":3,"sources":["../../../src/collections/BetterAuth/shared.ts"],"sourcesContent":["import type { Access, PayloadRequest } from 'payload'\n\nimport type { SecondaryStorage } from '../../storage/types'\n\nimport { type CryptoSignature, verifyCanonical } from '../../better-auth/crypto-shared'\nimport { NONCE_PREFIX } from '../../storage/keys'\n\nconst INTERNAL_SECRET = process.env.BA_TO_PAYLOAD_SECRET!\nconst NONCE_TTL_SECONDS = 5 * 60 // 5 minutes in seconds\n\n/**\n * Create the signature verification function for BA sync operations.\n * Uses storage for nonce checking to prevent replay attacks.\n */\nexport function createSigVerifier(storage: SecondaryStorage) {\n  return async function verifySig(\n    req: { context: { baBody?: unknown; baSig?: CryptoSignature } } & PayloadRequest,\n  ): Promise<boolean> {\n    const sig = req.context.baSig\n    const body = req.context.baBody\n    if (!sig || !body) {\n      return false\n    }\n\n    // Verify HMAC signature (includes timestamp check)\n    const ok = verifyCanonical(body, sig, INTERNAL_SECRET)\n    if (!ok) {\n      return false\n    }\n\n    // Check nonce for replay protection\n    const alreadyUsed = await storage.get(NONCE_PREFIX + sig.nonce)\n    if (alreadyUsed !== null) {\n      return false // replay detected\n    }\n\n    return true\n  }\n}\n\n/**\n * Mark a nonce as used via secondary storage.\n */\nexport async function markNonceUsed(storage: SecondaryStorage, nonce: string): Promise<void> {\n  await storage.set(NONCE_PREFIX + nonce, '1', NONCE_TTL_SECONDS)\n}\n\n/**\n * Create access control for BA collections.\n * - create/update: BA sync agent only (non-extensible)\n * - read/delete: BA sync agent only by default, can be extended via custom access\n * Handles both sync and async access functions from developers.\n */\nexport function createBACollectionAccess(\n  storage: SecondaryStorage,\n  customAccess?: {\n    delete?: Access\n    read?: Access\n  },\n) {\n  const verifySig = createSigVerifier(storage)\n\n  return {\n    // Create: BA sync agent only - NOT extensible\n    create: async ({ req }: { req: PayloadRequest }) => verifySig(req),\n\n    // Delete: BA sync agent OR custom access (handles both sync and async)\n    delete: async (args: Parameters<Access>[0]) => {\n      const sigOk = await verifySig(args.req)\n      if (sigOk) {\n        return true\n      }\n      if (customAccess?.delete) {\n        return await Promise.resolve(customAccess.delete(args))\n      }\n      return false\n    },\n\n    // Read: BA sync agent OR custom access (handles both sync and async)\n    read: async (args: Parameters<Access>[0]) => {\n      const sigOk = await verifySig(args.req)\n      if (sigOk) {\n        return true\n      }\n      if (customAccess?.read) {\n        return await Promise.resolve(customAccess.read(args))\n      }\n      return false\n    },\n\n    // Update: BA sync agent only - NOT extensible\n    update: async ({ req }: { req: PayloadRequest }) => verifySig(req),\n  }\n}\n\n/**\n * Shared fields for all BA collections.\n * All fields are read-only in the admin UI.\n */\nexport const sharedBAFields = [\n  {\n    name: 'baAccountId',\n    type: 'text' as const,\n    admin: { readOnly: true },\n    index: true,\n    required: true,\n    unique: true,\n  },\n  {\n    name: 'baUserId',\n    type: 'text' as const,\n    admin: { readOnly: true },\n    index: true,\n    required: true,\n  },\n  {\n    name: 'email',\n    type: 'email' as const,\n    admin: { readOnly: true },\n    required: true,\n  },\n  {\n    name: 'emailVerified',\n    type: 'checkbox' as const,\n    admin: { readOnly: true },\n    defaultValue: false,\n  },\n]\n\nexport { INTERNAL_SECRET }\n"],"names":["verifyCanonical","NONCE_PREFIX","INTERNAL_SECRET","process","env","BA_TO_PAYLOAD_SECRET","NONCE_TTL_SECONDS","createSigVerifier","storage","verifySig","req","sig","context","baSig","body","baBody","ok","alreadyUsed","get","nonce","markNonceUsed","set","createBACollectionAccess","customAccess","create","delete","args","sigOk","Promise","resolve","read","update","sharedBAFields","name","type","admin","readOnly","index","required","unique","defaultValue"],"mappings":"AAIA,SAA+BA,eAAe,QAAQ,kCAAiC;AACvF,SAASC,YAAY,QAAQ,qBAAoB;AAEjD,MAAMC,kBAAkBC,QAAQC,GAAG,CAACC,oBAAoB;AACxD,MAAMC,oBAAoB,IAAI,GAAG,uBAAuB;;AAExD;;;CAGC,GACD,OAAO,SAASC,kBAAkBC,OAAyB;IACzD,OAAO,eAAeC,UACpBC,GAAgF;QAEhF,MAAMC,MAAMD,IAAIE,OAAO,CAACC,KAAK;QAC7B,MAAMC,OAAOJ,IAAIE,OAAO,CAACG,MAAM;QAC/B,IAAI,CAACJ,OAAO,CAACG,MAAM;YACjB,OAAO;QACT;QAEA,mDAAmD;QACnD,MAAME,KAAKhB,gBAAgBc,MAAMH,KAAKT;QACtC,IAAI,CAACc,IAAI;YACP,OAAO;QACT;QAEA,oCAAoC;QACpC,MAAMC,cAAc,MAAMT,QAAQU,GAAG,CAACjB,eAAeU,IAAIQ,KAAK;QAC9D,IAAIF,gBAAgB,MAAM;YACxB,OAAO,MAAM,kBAAkB;;QACjC;QAEA,OAAO;IACT;AACF;AAEA;;CAEC,GACD,OAAO,eAAeG,cAAcZ,OAAyB,EAAEW,KAAa;IAC1E,MAAMX,QAAQa,GAAG,CAACpB,eAAekB,OAAO,KAAKb;AAC/C;AAEA;;;;;CAKC,GACD,OAAO,SAASgB,yBACdd,OAAyB,EACzBe,YAGC;IAED,MAAMd,YAAYF,kBAAkBC;IAEpC,OAAO;QACL,8CAA8C;QAC9CgB,QAAQ,OAAO,EAAEd,GAAG,EAA2B,GAAKD,UAAUC;QAE9D,uEAAuE;QACvEe,QAAQ,OAAOC;YACb,MAAMC,QAAQ,MAAMlB,UAAUiB,KAAKhB,GAAG;YACtC,IAAIiB,OAAO;gBACT,OAAO;YACT;YACA,IAAIJ,cAAcE,QAAQ;gBACxB,OAAO,MAAMG,QAAQC,OAAO,CAACN,aAAaE,MAAM,CAACC;YACnD;YACA,OAAO;QACT;QAEA,qEAAqE;QACrEI,MAAM,OAAOJ;YACX,MAAMC,QAAQ,MAAMlB,UAAUiB,KAAKhB,GAAG;YACtC,IAAIiB,OAAO;gBACT,OAAO;YACT;YACA,IAAIJ,cAAcO,MAAM;gBACtB,OAAO,MAAMF,QAAQC,OAAO,CAACN,aAAaO,IAAI,CAACJ;YACjD;YACA,OAAO;QACT;QAEA,8CAA8C;QAC9CK,QAAQ,OAAO,EAAErB,GAAG,EAA2B,GAAKD,UAAUC;IAChE;AACF;AAEA;;;CAGC,GACD,OAAO,MAAMsB,iBAAiB;IAC5B;QACEC,MAAM;QACNC,MAAM;QACNC,OAAO;YAAEC,UAAU;QAAK;QACxBC,OAAO;QACPC,UAAU;QACVC,QAAQ;IACV;IACA;QACEN,MAAM;QACNC,MAAM;QACNC,OAAO;YAAEC,UAAU;QAAK;QACxBC,OAAO;QACPC,UAAU;IACZ;IACA;QACEL,MAAM;QACNC,MAAM;QACNC,OAAO;YAAEC,UAAU;QAAK;QACxBE,UAAU;IACZ;IACA;QACEL,MAAM;QACNC,MAAM;QACNC,OAAO;YAAEC,UAAU;QAAK;QACxBI,cAAc;IAChB;CACD,CAAA;AAED,SAAStC,eAAe,GAAE"}