{"version":3,"sources":["../../../src/collections/BetterAuth/magicLink.ts"],"sourcesContent":["import type { Access, CollectionConfig } from 'payload'\n\nimport { APIError } from 'payload'\n\nimport type { SecondaryStorage } from '../../storage/types'\n\nimport { type CryptoSignature, verifyCanonical } from '../../better-auth/crypto-shared'\nimport {\n  createBACollectionAccess,\n  createSigVerifier,\n  INTERNAL_SECRET,\n  markNonceUsed,\n  sharedBAFields,\n} from './shared'\n\nexport interface CreateMagicLinkCollectionOptions {\n  /**\n   * Custom access rules for extensible operations (read, delete).\n   * These are OR'd with the BA sync agent check.\n   */\n  access?: {\n    delete?: Access\n    read?: Access\n  }\n  /**\n   * When true, shows this collection in admin UI under \"Better Auth (DEBUG)\" group.\n   * When false, hides from admin navigation.\n   */\n  isVisible?: boolean\n  /**\n   * Prefix for the collection slug (default: '__better_auth')\n   */\n  prefix?: string\n  /**\n   * Secondary storage for signature verification and nonce protection.\n   */\n  storage: SecondaryStorage\n}\n\n/**\n * Creates the Better Auth magic link collection.\n * Stores account data for users who authenticate via magic link.\n */\nexport function createMagicLinkCollection({\n  access: customAccess,\n  isVisible = false,\n  prefix = '__better_auth',\n  storage,\n}: CreateMagicLinkCollectionOptions): CollectionConfig {\n  const slug = `${prefix}_magic_link`\n  const verifySig = createSigVerifier(storage)\n\n  return {\n    slug,\n    access: createBACollectionAccess(storage, customAccess),\n    admin: {\n      defaultColumns: ['email', 'emailVerified', 'createdAt'],\n      group: isVisible ? 'Better Auth (DEBUG)' : undefined,\n      hidden: !isVisible,\n      useAsTitle: 'email',\n    },\n    fields: [\n      ...sharedBAFields,\n      // Join field to display the reverse relationship from users\n      // References the polymorphic betterAuthAccounts field\n      {\n        name: 'user',\n        type: 'join',\n        collection: 'users',\n        on: 'betterAuthAccounts',\n      },\n    ],\n    hooks: {\n      beforeChange: [\n        async ({ data, operation, originalDoc, req }) => {\n          const sig = req.context.baSig as CryptoSignature | undefined\n\n          if (operation === 'create') {\n            const expectedBody = { accountId: data.baAccountId, collection: slug, op: 'create' }\n            if (!sig || !verifyCanonical(expectedBody, sig, INTERNAL_SECRET)) {\n              throw new APIError('This collection is managed by Better Auth.')\n            }\n            await markNonceUsed(storage, sig.nonce)\n          } else if (operation === 'update') {\n            const accountId = originalDoc?.baAccountId || data.baAccountId\n            const expectedBody = { accountId, collection: slug, op: 'update' }\n            if (!sig || !verifyCanonical(expectedBody, sig, INTERNAL_SECRET)) {\n              throw new APIError('This collection is managed by Better Auth.')\n            }\n            await markNonceUsed(storage, sig.nonce)\n          }\n          return data\n        },\n      ],\n      beforeDelete: [\n        async ({ id, req }) => {\n          // Only check signature if not already verified in access control\n          const sigOk = await verifySig(req)\n          if (!sigOk) {\n            // Allow if custom delete access was granted\n            // The access control already verified either sig OR custom access\n            // But we need the sig for nonce marking if it was a BA operation\n            return\n          }\n\n          const sig = req.context.baSig as CryptoSignature | undefined\n          if (sig) {\n            await markNonceUsed(storage, sig.nonce)\n          }\n        },\n      ],\n    },\n    timestamps: true,\n  }\n}\n"],"names":["APIError","verifyCanonical","createBACollectionAccess","createSigVerifier","INTERNAL_SECRET","markNonceUsed","sharedBAFields","createMagicLinkCollection","access","customAccess","isVisible","prefix","storage","slug","verifySig","admin","defaultColumns","group","undefined","hidden","useAsTitle","fields","name","type","collection","on","hooks","beforeChange","data","operation","originalDoc","req","sig","context","baSig","expectedBody","accountId","baAccountId","op","nonce","beforeDelete","id","sigOk","timestamps"],"mappings":"AAEA,SAASA,QAAQ,QAAQ,UAAS;AAIlC,SAA+BC,eAAe,QAAQ,kCAAiC;AACvF,SACEC,wBAAwB,EACxBC,iBAAiB,EACjBC,eAAe,EACfC,aAAa,EACbC,cAAc,QACT,WAAU;AA0BjB;;;CAGC,GACD,OAAO,SAASC,0BAA0B,EACxCC,QAAQC,YAAY,EACpBC,YAAY,KAAK,EACjBC,SAAS,eAAe,EACxBC,OAAO,EAC0B;IACjC,MAAMC,OAAO,GAAGF,OAAO,WAAW,CAAC;IACnC,MAAMG,YAAYX,kBAAkBS;IAEpC,OAAO;QACLC;QACAL,QAAQN,yBAAyBU,SAASH;QAC1CM,OAAO;YACLC,gBAAgB;gBAAC;gBAAS;gBAAiB;aAAY;YACvDC,OAAOP,YAAY,wBAAwBQ;YAC3CC,QAAQ,CAACT;YACTU,YAAY;QACd;QACAC,QAAQ;eACHf;YACH,4DAA4D;YAC5D,sDAAsD;YACtD;gBACEgB,MAAM;gBACNC,MAAM;gBACNC,YAAY;gBACZC,IAAI;YACN;SACD;QACDC,OAAO;YACLC,cAAc;gBACZ,OAAO,EAAEC,IAAI,EAAEC,SAAS,EAAEC,WAAW,EAAEC,GAAG,EAAE;oBAC1C,MAAMC,MAAMD,IAAIE,OAAO,CAACC,KAAK;oBAE7B,IAAIL,cAAc,UAAU;wBAC1B,MAAMM,eAAe;4BAAEC,WAAWR,KAAKS,WAAW;4BAAEb,YAAYX;4BAAMyB,IAAI;wBAAS;wBACnF,IAAI,CAACN,OAAO,CAAC/B,gBAAgBkC,cAAcH,KAAK5B,kBAAkB;4BAChE,MAAM,IAAIJ,SAAS;wBACrB;wBACA,MAAMK,cAAcO,SAASoB,IAAIO,KAAK;oBACxC,OAAO,IAAIV,cAAc,UAAU;wBACjC,MAAMO,YAAYN,aAAaO,eAAeT,KAAKS,WAAW;wBAC9D,MAAMF,eAAe;4BAAEC;4BAAWZ,YAAYX;4BAAMyB,IAAI;wBAAS;wBACjE,IAAI,CAACN,OAAO,CAAC/B,gBAAgBkC,cAAcH,KAAK5B,kBAAkB;4BAChE,MAAM,IAAIJ,SAAS;wBACrB;wBACA,MAAMK,cAAcO,SAASoB,IAAIO,KAAK;oBACxC;oBACA,OAAOX;gBACT;aACD;YACDY,cAAc;gBACZ,OAAO,EAAEC,EAAE,EAAEV,GAAG,EAAE;oBAChB,iEAAiE;oBACjE,MAAMW,QAAQ,MAAM5B,UAAUiB;oBAC9B,IAAI,CAACW,OAAO;wBACV,4CAA4C;wBAC5C,kEAAkE;wBAClE,iEAAiE;wBACjE;oBACF;oBAEA,MAAMV,MAAMD,IAAIE,OAAO,CAACC,KAAK;oBAC7B,IAAIF,KAAK;wBACP,MAAM3B,cAAcO,SAASoB,IAAIO,KAAK;oBACxC;gBACF;aACD;QACH;QACAI,YAAY;IACd;AACF"}