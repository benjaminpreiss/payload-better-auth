{"version":3,"sources":["../../../src/collections/Users/index.ts"],"sourcesContent":["import type {\n  Access,\n  CollectionConfig,\n  CollectionSlug,\n  Field,\n  Payload,\n  PayloadRequest,\n} from 'payload'\n\nimport type { SecondaryStorage } from '../../storage/types'\n\nimport { type CryptoSignature, verifyCanonical } from '../../better-auth/crypto-shared'\nimport { NONCE_PREFIX, SESSION_COOKIE_NAME_KEY } from '../../storage/keys'\n\nconst INTERNAL_SECRET = process.env.BA_TO_PAYLOAD_SECRET!\nconst NONCE_TTL_SECONDS = 5 * 60 // 5 minutes in seconds\n\n/**\n * Extract ALL session tokens from cookies that match the expected cookie name.\n * This handles cases where multiple cookies with the same name exist (different paths/domains).\n * Returns tokens in order they appear (first = most recent typically).\n */\nasync function extractAllSessionTokens(\n  headers: Headers,\n  storage: SecondaryStorage,\n): Promise<string[]> {\n  const cookieHeader = headers.get('cookie')\n  if (!cookieHeader) {\n    return []\n  }\n\n  // Get cookie name from storage (set by Better Auth plugin)\n  const sessionCookieName =\n    (await storage.get(SESSION_COOKIE_NAME_KEY)) ?? 'better-auth.session_token'\n\n  // Parse ALL cookies, keeping duplicates\n  const tokens: string[] = []\n  for (const cookie of cookieHeader.split(';')) {\n    const trimmed = cookie.trim()\n    const eqIndex = trimmed.indexOf('=')\n    if (eqIndex === -1) {\n      continue\n    }\n\n    const key = trimmed.slice(0, eqIndex)\n    const value = trimmed.slice(eqIndex + 1)\n\n    if (key === sessionCookieName && value) {\n      try {\n        tokens.push(decodeURIComponent(value))\n      } catch {\n        // Skip malformed cookies\n      }\n    }\n  }\n\n  return tokens\n}\n\n/**\n * Better Auth session data format in secondaryStorage.\n * Better Auth stores sessions with this structure when secondaryStorage is configured.\n */\ninterface BetterAuthStoredSession {\n  session: {\n    expiresAt: Date | string\n    id: string\n    userId: string\n  }\n  user: {\n    [key: string]: unknown\n    id: string\n  }\n}\n\n/**\n * Create the signature verification function.\n * Uses storage for nonce checking to prevent replay attacks.\n */\nfunction createSigVerifier(storage: SecondaryStorage) {\n  return async function verifySig(\n    req: { context: { baBody?: unknown; baSig?: CryptoSignature } } & PayloadRequest,\n  ): Promise<boolean> {\n    const sig = req.context.baSig\n    const body = req.context.baBody\n    if (!sig || !body) {\n      return false\n    }\n\n    // Verify HMAC signature (includes timestamp check)\n    const ok = verifyCanonical(body, sig, INTERNAL_SECRET)\n    if (!ok) {\n      return false\n    }\n\n    // Check nonce for replay protection\n    const alreadyUsed = await storage.get(NONCE_PREFIX + sig.nonce)\n    if (alreadyUsed !== null) {\n      return false // replay detected\n    }\n\n    return true\n  }\n}\n\n/**\n * Mark a nonce as used via secondary storage.\n */\nasync function markNonceUsed(storage: SecondaryStorage, nonce: string): Promise<void> {\n  await storage.set(NONCE_PREFIX + nonce, '1', NONCE_TTL_SECONDS)\n}\n\nexport interface ExtendUsersCollectionOptions {\n  /**\n   * Prefix for Better Auth collection slugs (default: '__better_auth')\n   */\n  collectionPrefix?: string\n  /**\n   * Secondary storage for session validation and nonce protection.\n   * Sessions are read directly from storage - no HTTP calls to Better Auth.\n   *\n   * This must be the same storage instance passed to the Better Auth plugin,\n   * as Better Auth writes sessions to this storage via secondaryStorage.\n   */\n  storage: SecondaryStorage\n}\n\n/**\n * Field-level access that only allows BA sync agent to update.\n * Checks for BA signature in request context.\n */\nconst baOnlyFieldAccess = {\n  // BA sync agent sets baSig in context - only allow update if present\n  update: ({ req }: { req: PayloadRequest }) => Boolean(req.context?.baSig),\n}\n\n/**\n * Better Auth fields to add to the users collection.\n * Includes a polymorphic relationship field to BA collections.\n */\nfunction getBetterAuthFields<TCollectionSlug extends string>(\n  emailPasswordSlug: TCollectionSlug,\n  magicLinkSlug: TCollectionSlug,\n): Field[] {\n  return [\n    {\n      name: 'baUserId',\n      type: 'text',\n      access: baOnlyFieldAccess,\n      admin: { readOnly: true },\n      index: true,\n      unique: true,\n    },\n    {\n      // Polymorphic relationship: one field can reference multiple BA collections\n      // A user can have multiple auth methods (e.g., email/password AND magic-link)\n      name: 'betterAuthAccounts',\n      type: 'relationship',\n      access: baOnlyFieldAccess,\n      admin: { readOnly: true },\n      hasMany: true,\n      relationTo: [emailPasswordSlug, magicLinkSlug] as CollectionSlug[],\n    },\n  ]\n}\n\n/**\n * Validate a session token and return the user ID if valid.\n * Returns null if token is invalid or expired.\n */\nasync function validateSessionToken(\n  fullToken: string,\n  storage: SecondaryStorage,\n): Promise<null | string> {\n  // Better Auth cookie format: \"token.signature\" - we need just the token part\n  const token = fullToken.split('.')[0]\n  if (!token) {\n    return null\n  }\n\n  // Read session directly from storage (written by Better Auth)\n  const cached = await storage.get(token)\n  if (!cached) {\n    return null\n  }\n\n  try {\n    const storedSession = JSON.parse(cached) as BetterAuthStoredSession\n    // Check expiration - Better Auth stores expiresAt as ISO string or Date\n    const expiresAt =\n      typeof storedSession.session.expiresAt === 'string'\n        ? new Date(storedSession.session.expiresAt).getTime()\n        : new Date(storedSession.session.expiresAt).getTime()\n\n    if (expiresAt > Date.now()) {\n      return storedSession.session.userId\n    }\n  } catch {\n    // Invalid JSON in storage\n  }\n\n  return null\n}\n\n/**\n * Create the Better Auth authentication strategy.\n * Tries all session cookies until finding a valid, non-expired session.\n */\nfunction createBetterAuthStrategy(storage: SecondaryStorage, _prefix: string) {\n  return {\n    name: 'better-auth',\n    authenticate: async ({ headers, payload }: { headers: Headers; payload: Payload }) => {\n      // Get ALL session tokens from cookies (handles duplicates)\n      const tokens = await extractAllSessionTokens(headers, storage)\n      if (tokens.length === 0) {\n        return { user: null }\n      }\n\n      // Try each token until we find a valid session\n      for (const fullToken of tokens) {\n        const baUserId = await validateSessionToken(fullToken, storage)\n        if (!baUserId) {\n          continue // Try next token\n        }\n\n        // Find user by baUserId\n        const existing = await payload.find({\n          collection: 'users',\n          limit: 1,\n          where: { baUserId: { equals: baUserId } },\n        })\n\n        if (existing.docs[0]) {\n          return { user: { collection: 'users' as const, ...existing.docs[0] } }\n        }\n        // User not found in Payload, try next token\n      }\n\n      return { user: null }\n    },\n  }\n}\n\n/**\n * Create composable access control that OR's BA sync access with developer access.\n * Handles both sync and async access functions from developers.\n */\nfunction createComposableAccess(\n  storage: SecondaryStorage,\n  developerAccess: Access | undefined,\n  operation: 'create' | 'delete' | 'read' | 'update',\n) {\n  const verifySig = createSigVerifier(storage)\n\n  return async (args: Parameters<Access>[0]) => {\n    // BA sync agent always has access\n    const sigOk = await verifySig(args.req)\n    if (sigOk) {\n      return true\n    }\n\n    // Fall back to developer's access rules (handles both sync and async)\n    if (developerAccess) {\n      return await Promise.resolve(developerAccess(args))\n    }\n\n    // Default behavior by operation\n    if (operation === 'read') {\n      return Boolean(args.req.user) // authenticated users can read\n    }\n    return false // deny by default for create/update/delete\n  }\n}\n\n/**\n * Extends an existing users collection with Better Auth integration.\n * Merges BA fields, auth strategy, access control, and hooks.\n *\n * @param baseCollection - The developer's existing users collection config (or undefined for minimal)\n * @param options - Extension options including storage\n * @returns Extended collection config with BA integration\n */\nexport function extendUsersCollection(\n  baseCollection: CollectionConfig | undefined,\n  options: ExtendUsersCollectionOptions,\n): CollectionConfig {\n  const { collectionPrefix = '__better_auth', storage } = options\n  const verifySig = createSigVerifier(storage)\n\n  // Compute BA collection slugs\n  const emailPasswordSlug = `${collectionPrefix}_email_password`\n  const magicLinkSlug = `${collectionPrefix}_magic_link`\n\n  // Start with base or minimal collection\n  const base: CollectionConfig = baseCollection ?? {\n    slug: 'users',\n    fields: [],\n  }\n\n  // Ensure slug is 'users'\n  if (base.slug !== 'users') {\n    throw new Error('Users collection must have slug \"users\"')\n  }\n\n  // Get developer's existing access rules\n  const developerAccess = base.access ?? {}\n\n  // Get developer's existing hooks\n  const developerHooks = base.hooks ?? {}\n\n  // BA-specific beforeChange hook\n  const baBeforeChange = async ({\n    data,\n    operation,\n    originalDoc,\n    req,\n  }: {\n    data: Record<string, unknown>\n    operation: 'create' | 'update'\n    originalDoc?: Record<string, unknown>\n    req: PayloadRequest\n  }) => {\n    const sig = req.context.baSig as CryptoSignature | undefined\n\n    if (operation === 'create' && sig) {\n      const expectedBody = { collection: 'users', op: 'create', userId: data.baUserId }\n      if (verifyCanonical(expectedBody, sig, INTERNAL_SECRET)) {\n        await markNonceUsed(storage, sig.nonce)\n      }\n    } else if (operation === 'update' && sig) {\n      const userId = originalDoc?.baUserId || data.baUserId\n      const expectedBody = { collection: 'users', op: 'update', userId }\n      if (verifyCanonical(expectedBody, sig, INTERNAL_SECRET)) {\n        await markNonceUsed(storage, sig.nonce)\n      }\n    }\n    return data\n  }\n\n  // BA-specific beforeDelete hook\n  const baBeforeDelete = async ({ req }: { id: number | string; req: PayloadRequest }) => {\n    const sigOk = await verifySig(req)\n    if (sigOk) {\n      const sig = req.context.baSig as CryptoSignature | undefined\n      if (sig) {\n        await markNonceUsed(storage, sig.nonce)\n      }\n    }\n  }\n\n  return {\n    ...base,\n    access: {\n      admin: developerAccess.admin ?? (({ req: { user } }) => Boolean(user)),\n      create: createComposableAccess(storage, developerAccess.create as Access, 'create'),\n      delete: createComposableAccess(storage, developerAccess.delete as Access, 'delete'),\n      read: createComposableAccess(storage, developerAccess.read as Access, 'read'),\n      update: createComposableAccess(storage, developerAccess.update as Access, 'update'),\n    },\n    admin: {\n      ...base.admin,\n      defaultColumns: (() => {\n        const cols = base.admin?.defaultColumns ?? ['email', 'createdAt']\n        // Add BA accounts column if not already present\n        if (!cols.includes('betterAuthAccounts')) {\n          return [...cols, 'betterAuthAccounts']\n        }\n        return cols\n      })(),\n      useAsTitle: base.admin?.useAsTitle ?? 'email',\n    },\n    auth: {\n      ...(typeof base.auth === 'object' ? base.auth : {}),\n      disableLocalStrategy: true,\n      strategies: [\n        createBetterAuthStrategy(storage, collectionPrefix),\n        // Preserve any existing strategies (except local)\n        ...((typeof base.auth === 'object' && base.auth.strategies) || []),\n      ],\n    },\n    fields: [\n      // Developer's fields first\n      ...(base.fields ?? []),\n      // BA fields\n      ...getBetterAuthFields(emailPasswordSlug, magicLinkSlug),\n    ],\n    hooks: {\n      ...developerHooks,\n      beforeChange: [\n        // BA hook first\n        baBeforeChange,\n        // Then developer hooks\n        ...(developerHooks.beforeChange ?? []),\n      ],\n      beforeDelete: [\n        // BA hook first\n        baBeforeDelete,\n        // Then developer hooks\n        ...(developerHooks.beforeDelete ?? []),\n      ],\n    },\n    timestamps: base.timestamps ?? true,\n  }\n}\n\n/**\n * Creates a minimal users collection with Better Auth integration.\n * Use this when no custom users collection is defined.\n */\nexport function createMinimalUsersCollection(\n  options: ExtendUsersCollectionOptions,\n): CollectionConfig {\n  return extendUsersCollection(undefined, options)\n}\n"],"names":["verifyCanonical","NONCE_PREFIX","SESSION_COOKIE_NAME_KEY","INTERNAL_SECRET","process","env","BA_TO_PAYLOAD_SECRET","NONCE_TTL_SECONDS","extractAllSessionTokens","headers","storage","cookieHeader","get","sessionCookieName","tokens","cookie","split","trimmed","trim","eqIndex","indexOf","key","slice","value","push","decodeURIComponent","createSigVerifier","verifySig","req","sig","context","baSig","body","baBody","ok","alreadyUsed","nonce","markNonceUsed","set","baOnlyFieldAccess","update","Boolean","getBetterAuthFields","emailPasswordSlug","magicLinkSlug","name","type","access","admin","readOnly","index","unique","hasMany","relationTo","validateSessionToken","fullToken","token","cached","storedSession","JSON","parse","expiresAt","session","Date","getTime","now","userId","createBetterAuthStrategy","_prefix","authenticate","payload","length","user","baUserId","existing","find","collection","limit","where","equals","docs","createComposableAccess","developerAccess","operation","args","sigOk","Promise","resolve","extendUsersCollection","baseCollection","options","collectionPrefix","base","slug","fields","Error","developerHooks","hooks","baBeforeChange","data","originalDoc","expectedBody","op","baBeforeDelete","create","delete","read","defaultColumns","cols","includes","useAsTitle","auth","disableLocalStrategy","strategies","beforeChange","beforeDelete","timestamps","createMinimalUsersCollection","undefined"],"mappings":"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"}