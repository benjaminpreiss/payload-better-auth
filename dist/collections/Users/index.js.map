{"version":3,"sources":["../../../src/collections/Users/index.ts"],"sourcesContent":["import type { AccessArgs, CollectionConfig, PayloadRequest, User } from 'payload'\n\nimport { APIError } from 'payload'\n\nimport type { SecondaryStorage } from '../../storage/types'\n\nimport { type CryptoSignature, verifyCanonical } from '../../better-auth/crypto-shared'\nimport { NONCE_PREFIX, SESSION_COOKIE_NAME_KEY } from '../../storage/keys'\n\nconst INTERNAL_SECRET = process.env.BA_TO_PAYLOAD_SECRET!\nconst NONCE_TTL_SECONDS = 5 * 60 // 5 minutes in seconds\n\ntype isAuthenticated = (args: AccessArgs<User>) => boolean\nconst authenticated: isAuthenticated = ({ req: { user } }) => {\n  return Boolean(user)\n}\n\n/**\n * Extract session token from cookies in headers.\n * Reads the cookie name from KV storage (set by Better Auth plugin).\n * Falls back to 'better-auth.session_token' if config not found.\n */\nasync function extractSessionToken(\n  headers: Headers,\n  storage: SecondaryStorage,\n): Promise<null | string> {\n  const cookieHeader = headers.get('cookie')\n  if (!cookieHeader) {\n    return null\n  }\n\n  // Parse cookies\n  const cookies = cookieHeader.split(';').reduce(\n    (acc, cookie) => {\n      const [key, value] = cookie.trim().split('=')\n      if (key && value) {\n        acc[key] = decodeURIComponent(value)\n      }\n      return acc\n    },\n    {} as Record<string, string>,\n  )\n\n  // Get cookie name from storage (set by Better Auth plugin)\n  const sessionCookieName =\n    (await storage.get(SESSION_COOKIE_NAME_KEY)) ?? 'better-auth.session_token'\n\n  return cookies[sessionCookieName] ?? null\n}\n\n/**\n * Better Auth session data format in secondaryStorage.\n * Better Auth stores sessions with this structure when secondaryStorage is configured.\n */\ninterface BetterAuthStoredSession {\n  session: {\n    expiresAt: Date | string\n    id: string\n    userId: string\n  }\n  user: {\n    [key: string]: unknown\n    id: string\n  }\n}\n\n/**\n * Create the signature verification function.\n * Uses storage for nonce checking to prevent replay attacks.\n */\nfunction createSigVerifier(storage: SecondaryStorage) {\n  return async function basicSigOk(\n    req: { context: { baSig?: CryptoSignature } } & PayloadRequest,\n  ): Promise<boolean> {\n    const sig = req.context.baSig\n    const body = req.context.baBody\n    if (!sig || !body) {\n      return false\n    }\n\n    // Verify HMAC signature (includes timestamp check)\n    const ok = verifyCanonical(body, sig, INTERNAL_SECRET)\n    if (!ok) {\n      return false\n    }\n\n    // Check nonce for replay protection\n    const alreadyUsed = await storage.get(NONCE_PREFIX + sig.nonce)\n    if (alreadyUsed !== null) {\n      return false // replay detected\n    }\n\n    return true\n  }\n}\n\n/**\n * Mark a nonce as used via secondary storage.\n */\nasync function markNonceUsed(storage: SecondaryStorage, nonce: string): Promise<void> {\n  await storage.set(NONCE_PREFIX + nonce, '1', NONCE_TTL_SECONDS)\n}\n\nexport interface CreateUsersCollectionOptions {\n  /**\n   * Secondary storage for session validation and nonce protection.\n   * Sessions are read directly from storage - no HTTP calls to Better Auth.\n   *\n   * This must be the same storage instance passed to the Better Auth plugin,\n   * as Better Auth writes sessions to this storage via secondaryStorage.\n   *\n   * @example\n   * import { createSqliteStorage } from 'payload-better-auth'\n   * import { DatabaseSync } from 'node:sqlite'\n   * const db = new DatabaseSync('.sync-state.db')\n   * const storage = createSqliteStorage({ db })\n   */\n  storage: SecondaryStorage\n}\n\nexport function createUsersCollection({ storage }: CreateUsersCollectionOptions): CollectionConfig {\n  const verifySig = createSigVerifier(storage)\n\n  return {\n    slug: 'users',\n    access: {\n      admin: authenticated,\n      // Disable manual user management through Payload admin\n      // Users can only be managed through better-auth\n      create: async ({ req }) => verifySig(req),\n      delete: async ({ req }) => verifySig(req),\n      read: authenticated,\n      update: async ({ req }) => verifySig(req),\n    },\n    admin: {\n      defaultColumns: ['name', 'email'],\n      useAsTitle: 'name',\n    },\n    auth: {\n      disableLocalStrategy: true,\n      strategies: [\n        {\n          name: 'better-auth',\n          authenticate: async ({ headers, payload }) => {\n            // Get session token from cookie\n            const fullToken = await extractSessionToken(headers, storage)\n            if (!fullToken) {\n              return { user: null }\n            }\n\n            // Better Auth cookie format: \"token.signature\" - we need just the token part\n            const token = fullToken.split('.')[0]\n\n            // Read session directly from storage (written by Better Auth)\n            // Better Auth stores sessions with just the token as the key (no prefix)\n            const cached = await storage.get(token)\n            if (!cached) {\n              return { user: null }\n            }\n\n            let externalId: null | string = null\n            try {\n              const storedSession = JSON.parse(cached) as BetterAuthStoredSession\n              // Check expiration - Better Auth stores expiresAt as ISO string or Date\n              const expiresAt =\n                typeof storedSession.session.expiresAt === 'string'\n                  ? new Date(storedSession.session.expiresAt).getTime()\n                  : new Date(storedSession.session.expiresAt).getTime()\n              if (expiresAt > Date.now()) {\n                externalId = storedSession.session.userId\n              }\n            } catch {\n              // Invalid JSON in storage\n              return { user: null }\n            }\n\n            if (!externalId) {\n              return { user: null }\n            }\n\n            // Find or provision the minimal Payload user\n            const existing = await payload.find({\n              collection: 'users',\n              limit: 1,\n              where: { externalId: { equals: externalId } },\n            })\n            const doc =\n              existing.docs[0] ??\n              (await payload.create({\n                collection: 'users',\n                data: { externalId },\n              }))\n\n            return { user: { collection: 'users', ...doc } }\n          },\n        },\n      ],\n    },\n    fields: [\n      { name: 'externalId', type: 'text', index: true, required: true, unique: true },\n      {\n        name: 'name',\n        type: 'text',\n      },\n    ],\n    hooks: {\n      beforeChange: [\n        async ({ data, operation, originalDoc, req }) => {\n          if (operation === 'create') {\n            // authoritative check: tie signature to the actual mutation\n            const sig = req.context.baSig as CryptoSignature | undefined\n            const expectedBody = { op: 'create', userId: data.externalId }\n            if (!sig || !verifyCanonical(expectedBody, sig, INTERNAL_SECRET)) {\n              return Promise.reject(new APIError('User creation is managed by Better Auth.'))\n            }\n            // mark nonce as used via storage\n            await markNonceUsed(storage, sig.nonce)\n          } else if (operation === 'update') {\n            // authoritative check: tie signature to the actual mutation\n            const sig = req.context.baSig as CryptoSignature | undefined\n            const userId = originalDoc?.externalId || data.externalId\n            const expectedBody = { op: 'update', userId }\n            if (!sig || !verifyCanonical(expectedBody, sig, INTERNAL_SECRET)) {\n              return Promise.reject(new APIError('User updates are managed by Better Auth.'))\n            }\n            // mark nonce as used via storage\n            await markNonceUsed(storage, sig.nonce)\n          }\n          return data\n        },\n      ],\n      beforeDelete: [\n        async ({ id, req }) => {\n          // Get the document first to access externalId\n          const doc = await req.payload.findByID({\n            id,\n            collection: 'users',\n          })\n\n          const sig = req.context.baSig as CryptoSignature | undefined\n          const expectedBody = { op: 'delete', userId: doc.externalId }\n          if (!sig || !verifyCanonical(expectedBody, sig, INTERNAL_SECRET)) {\n            return Promise.reject(new APIError('User deletion is managed by Better Auth.'))\n          }\n          // mark nonce as used via storage\n          await markNonceUsed(storage, sig.nonce)\n        },\n      ],\n    },\n    timestamps: true,\n  }\n}\n"],"names":["APIError","verifyCanonical","NONCE_PREFIX","SESSION_COOKIE_NAME_KEY","INTERNAL_SECRET","process","env","BA_TO_PAYLOAD_SECRET","NONCE_TTL_SECONDS","authenticated","req","user","Boolean","extractSessionToken","headers","storage","cookieHeader","get","cookies","split","reduce","acc","cookie","key","value","trim","decodeURIComponent","sessionCookieName","createSigVerifier","basicSigOk","sig","context","baSig","body","baBody","ok","alreadyUsed","nonce","markNonceUsed","set","createUsersCollection","verifySig","slug","access","admin","create","delete","read","update","defaultColumns","useAsTitle","auth","disableLocalStrategy","strategies","name","authenticate","payload","fullToken","token","cached","externalId","storedSession","JSON","parse","expiresAt","session","Date","getTime","now","userId","existing","find","collection","limit","where","equals","doc","docs","data","fields","type","index","required","unique","hooks","beforeChange","operation","originalDoc","expectedBody","op","Promise","reject","beforeDelete","id","findByID","timestamps"],"mappings":"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"}