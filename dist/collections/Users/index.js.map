{"version":3,"sources":["../../../src/collections/Users/index.ts"],"sourcesContent":["import type { AccessArgs, CollectionConfig, PayloadRequest, User } from 'payload'\n\nimport { APIError } from 'payload'\n\nimport type { SecondaryStorage } from '../../storage/types'\n\nimport { type CryptoSignature, verifyCanonical } from '../../better-auth/crypto-shared'\n\nconst INTERNAL_SECRET = process.env.BA_TO_PAYLOAD_SECRET!\nconst NONCE_TTL_SECONDS = 5 * 60 // 5 minutes in seconds\n\n// Key prefixes for storage\n// Better Auth stores sessions WITHOUT a prefix - just the token as the key\nconst NONCE_PREFIX = 'nonce:'\n\ntype isAuthenticated = (args: AccessArgs<User>) => boolean\nconst authenticated: isAuthenticated = ({ req: { user } }) => {\n  return Boolean(user)\n}\n\n/**\n * Extract session token from cookies in headers.\n * Better Auth uses 'better-auth.session_token' cookie by default.\n */\nfunction extractSessionToken(headers: Headers): null | string {\n  const cookieHeader = headers.get('cookie')\n  if (!cookieHeader) {\n    return null\n  }\n\n  // Parse cookies\n  const cookies = cookieHeader.split(';').reduce(\n    (acc, cookie) => {\n      const [key, value] = cookie.trim().split('=')\n      if (key && value) {\n        acc[key] = decodeURIComponent(value)\n      }\n      return acc\n    },\n    {} as Record<string, string>,\n  )\n\n  // Better Auth session cookie name\n  return cookies['better-auth.session_token'] ?? null\n}\n\n/**\n * Better Auth session data format in secondaryStorage.\n * Better Auth stores sessions with this structure when secondaryStorage is configured.\n */\ninterface BetterAuthStoredSession {\n  session: {\n    expiresAt: Date | string\n    id: string\n    userId: string\n  }\n  user: {\n    [key: string]: unknown\n    id: string\n  }\n}\n\n/**\n * Create the signature verification function.\n * Uses storage for nonce checking to prevent replay attacks.\n */\nfunction createSigVerifier(storage: SecondaryStorage) {\n  return async function basicSigOk(\n    req: { context: { baSig?: CryptoSignature } } & PayloadRequest,\n  ): Promise<boolean> {\n    const sig = req.context.baSig\n    const body = req.context.baBody\n    if (!sig || !body) {\n      return false\n    }\n\n    // Verify HMAC signature (includes timestamp check)\n    const ok = verifyCanonical(body, sig, INTERNAL_SECRET)\n    if (!ok) {\n      return false\n    }\n\n    // Check nonce for replay protection\n    const alreadyUsed = await storage.get(NONCE_PREFIX + sig.nonce)\n    if (alreadyUsed !== null) {\n      return false // replay detected\n    }\n\n    return true\n  }\n}\n\n/**\n * Mark a nonce as used via secondary storage.\n */\nasync function markNonceUsed(storage: SecondaryStorage, nonce: string): Promise<void> {\n  await storage.set(NONCE_PREFIX + nonce, '1', NONCE_TTL_SECONDS)\n}\n\nexport interface CreateUsersCollectionOptions {\n  /**\n   * Secondary storage for session validation and nonce protection.\n   * Sessions are read directly from storage - no HTTP calls to Better Auth.\n   *\n   * This must be the same storage instance passed to the Better Auth plugin,\n   * as Better Auth writes sessions to this storage via secondaryStorage.\n   *\n   * @example\n   * import { createSqliteStorage } from 'payload-better-auth'\n   * import { DatabaseSync } from 'node:sqlite'\n   * const db = new DatabaseSync('.sync-state.db')\n   * const storage = createSqliteStorage({ db })\n   */\n  storage: SecondaryStorage\n}\n\nexport function createUsersCollection({ storage }: CreateUsersCollectionOptions): CollectionConfig {\n  const verifySig = createSigVerifier(storage)\n\n  return {\n    slug: 'users',\n    access: {\n      admin: authenticated,\n      // Disable manual user management through Payload admin\n      // Users can only be managed through better-auth\n      create: async ({ req }) => verifySig(req),\n      delete: async ({ req }) => verifySig(req),\n      read: authenticated,\n      update: async ({ req }) => verifySig(req),\n    },\n    admin: {\n      defaultColumns: ['name', 'email'],\n      useAsTitle: 'name',\n    },\n    auth: {\n      disableLocalStrategy: true,\n      strategies: [\n        {\n          name: 'better-auth',\n          authenticate: async ({ headers, payload }) => {\n            // Get session token from cookie\n            const fullToken = extractSessionToken(headers)\n            if (!fullToken) {\n              return { user: null }\n            }\n\n            // Better Auth cookie format: \"token.signature\" - we need just the token part\n            const token = fullToken.split('.')[0]\n\n            // Read session directly from storage (written by Better Auth)\n            // Better Auth stores sessions with just the token as the key (no prefix)\n            const cached = await storage.get(token)\n            if (!cached) {\n              return { user: null }\n            }\n\n            let externalId: null | string = null\n            try {\n              const storedSession = JSON.parse(cached) as BetterAuthStoredSession\n              // Check expiration - Better Auth stores expiresAt as ISO string or Date\n              const expiresAt =\n                typeof storedSession.session.expiresAt === 'string'\n                  ? new Date(storedSession.session.expiresAt).getTime()\n                  : new Date(storedSession.session.expiresAt).getTime()\n              if (expiresAt > Date.now()) {\n                externalId = storedSession.session.userId\n              }\n            } catch {\n              // Invalid JSON in storage\n              return { user: null }\n            }\n\n            if (!externalId) {\n              return { user: null }\n            }\n\n            // Find or provision the minimal Payload user\n            const existing = await payload.find({\n              collection: 'users',\n              limit: 1,\n              where: { externalId: { equals: externalId } },\n            })\n            const doc =\n              existing.docs[0] ??\n              (await payload.create({\n                collection: 'users',\n                data: { externalId },\n              }))\n\n            return { user: { collection: 'users', ...doc } }\n          },\n        },\n      ],\n    },\n    fields: [\n      { name: 'externalId', type: 'text', index: true, required: true, unique: true },\n      {\n        name: 'name',\n        type: 'text',\n      },\n    ],\n    hooks: {\n      beforeChange: [\n        async ({ data, operation, originalDoc, req }) => {\n          if (operation === 'create') {\n            // authoritative check: tie signature to the actual mutation\n            const sig = req.context.baSig as CryptoSignature | undefined\n            const expectedBody = { op: 'create', userId: data.externalId }\n            if (!sig || !verifyCanonical(expectedBody, sig, INTERNAL_SECRET)) {\n              return Promise.reject(new APIError('User creation is managed by Better Auth.'))\n            }\n            // mark nonce as used via storage\n            await markNonceUsed(storage, sig.nonce)\n          } else if (operation === 'update') {\n            // authoritative check: tie signature to the actual mutation\n            const sig = req.context.baSig as CryptoSignature | undefined\n            const userId = originalDoc?.externalId || data.externalId\n            const expectedBody = { op: 'update', userId }\n            if (!sig || !verifyCanonical(expectedBody, sig, INTERNAL_SECRET)) {\n              return Promise.reject(new APIError('User updates are managed by Better Auth.'))\n            }\n            // mark nonce as used via storage\n            await markNonceUsed(storage, sig.nonce)\n          }\n          return data\n        },\n      ],\n      beforeDelete: [\n        async ({ id, req }) => {\n          // Get the document first to access externalId\n          const doc = await req.payload.findByID({\n            id,\n            collection: 'users',\n          })\n\n          const sig = req.context.baSig as CryptoSignature | undefined\n          const expectedBody = { op: 'delete', userId: doc.externalId }\n          if (!sig || !verifyCanonical(expectedBody, sig, INTERNAL_SECRET)) {\n            return Promise.reject(new APIError('User deletion is managed by Better Auth.'))\n          }\n          // mark nonce as used via storage\n          await markNonceUsed(storage, sig.nonce)\n        },\n      ],\n    },\n    timestamps: true,\n  }\n}\n"],"names":["APIError","verifyCanonical","INTERNAL_SECRET","process","env","BA_TO_PAYLOAD_SECRET","NONCE_TTL_SECONDS","NONCE_PREFIX","authenticated","req","user","Boolean","extractSessionToken","headers","cookieHeader","get","cookies","split","reduce","acc","cookie","key","value","trim","decodeURIComponent","createSigVerifier","storage","basicSigOk","sig","context","baSig","body","baBody","ok","alreadyUsed","nonce","markNonceUsed","set","createUsersCollection","verifySig","slug","access","admin","create","delete","read","update","defaultColumns","useAsTitle","auth","disableLocalStrategy","strategies","name","authenticate","payload","fullToken","token","cached","externalId","storedSession","JSON","parse","expiresAt","session","Date","getTime","now","userId","existing","find","collection","limit","where","equals","doc","docs","data","fields","type","index","required","unique","hooks","beforeChange","operation","originalDoc","expectedBody","op","Promise","reject","beforeDelete","id","findByID","timestamps"],"mappings":"AAEA,SAASA,QAAQ,QAAQ,UAAS;AAIlC,SAA+BC,eAAe,QAAQ,kCAAiC;AAEvF,MAAMC,kBAAkBC,QAAQC,GAAG,CAACC,oBAAoB;AACxD,MAAMC,oBAAoB,IAAI,GAAG,uBAAuB;;AAExD,2BAA2B;AAC3B,2EAA2E;AAC3E,MAAMC,eAAe;AAGrB,MAAMC,gBAAiC,CAAC,EAAEC,KAAK,EAAEC,IAAI,EAAE,EAAE;IACvD,OAAOC,QAAQD;AACjB;AAEA;;;CAGC,GACD,SAASE,oBAAoBC,OAAgB;IAC3C,MAAMC,eAAeD,QAAQE,GAAG,CAAC;IACjC,IAAI,CAACD,cAAc;QACjB,OAAO;IACT;IAEA,gBAAgB;IAChB,MAAME,UAAUF,aAAaG,KAAK,CAAC,KAAKC,MAAM,CAC5C,CAACC,KAAKC;QACJ,MAAM,CAACC,KAAKC,MAAM,GAAGF,OAAOG,IAAI,GAAGN,KAAK,CAAC;QACzC,IAAII,OAAOC,OAAO;YAChBH,GAAG,CAACE,IAAI,GAAGG,mBAAmBF;QAChC;QACA,OAAOH;IACT,GACA,CAAC;IAGH,kCAAkC;IAClC,OAAOH,OAAO,CAAC,4BAA4B,IAAI;AACjD;AAkBA;;;CAGC,GACD,SAASS,kBAAkBC,OAAyB;IAClD,OAAO,eAAeC,WACpBlB,GAA8D;QAE9D,MAAMmB,MAAMnB,IAAIoB,OAAO,CAACC,KAAK;QAC7B,MAAMC,OAAOtB,IAAIoB,OAAO,CAACG,MAAM;QAC/B,IAAI,CAACJ,OAAO,CAACG,MAAM;YACjB,OAAO;QACT;QAEA,mDAAmD;QACnD,MAAME,KAAKhC,gBAAgB8B,MAAMH,KAAK1B;QACtC,IAAI,CAAC+B,IAAI;YACP,OAAO;QACT;QAEA,oCAAoC;QACpC,MAAMC,cAAc,MAAMR,QAAQX,GAAG,CAACR,eAAeqB,IAAIO,KAAK;QAC9D,IAAID,gBAAgB,MAAM;YACxB,OAAO,MAAM,kBAAkB;;QACjC;QAEA,OAAO;IACT;AACF;AAEA;;CAEC,GACD,eAAeE,cAAcV,OAAyB,EAAES,KAAa;IACnE,MAAMT,QAAQW,GAAG,CAAC9B,eAAe4B,OAAO,KAAK7B;AAC/C;AAmBA,OAAO,SAASgC,sBAAsB,EAAEZ,OAAO,EAAgC;IAC7E,MAAMa,YAAYd,kBAAkBC;IAEpC,OAAO;QACLc,MAAM;QACNC,QAAQ;YACNC,OAAOlC;YACP,uDAAuD;YACvD,gDAAgD;YAChDmC,QAAQ,OAAO,EAAElC,GAAG,EAAE,GAAK8B,UAAU9B;YACrCmC,QAAQ,OAAO,EAAEnC,GAAG,EAAE,GAAK8B,UAAU9B;YACrCoC,MAAMrC;YACNsC,QAAQ,OAAO,EAAErC,GAAG,EAAE,GAAK8B,UAAU9B;QACvC;QACAiC,OAAO;YACLK,gBAAgB;gBAAC;gBAAQ;aAAQ;YACjCC,YAAY;QACd;QACAC,MAAM;YACJC,sBAAsB;YACtBC,YAAY;gBACV;oBACEC,MAAM;oBACNC,cAAc,OAAO,EAAExC,OAAO,EAAEyC,OAAO,EAAE;wBACvC,gCAAgC;wBAChC,MAAMC,YAAY3C,oBAAoBC;wBACtC,IAAI,CAAC0C,WAAW;4BACd,OAAO;gCAAE7C,MAAM;4BAAK;wBACtB;wBAEA,6EAA6E;wBAC7E,MAAM8C,QAAQD,UAAUtC,KAAK,CAAC,IAAI,CAAC,EAAE;wBAErC,8DAA8D;wBAC9D,yEAAyE;wBACzE,MAAMwC,SAAS,MAAM/B,QAAQX,GAAG,CAACyC;wBACjC,IAAI,CAACC,QAAQ;4BACX,OAAO;gCAAE/C,MAAM;4BAAK;wBACtB;wBAEA,IAAIgD,aAA4B;wBAChC,IAAI;4BACF,MAAMC,gBAAgBC,KAAKC,KAAK,CAACJ;4BACjC,wEAAwE;4BACxE,MAAMK,YACJ,OAAOH,cAAcI,OAAO,CAACD,SAAS,KAAK,WACvC,IAAIE,KAAKL,cAAcI,OAAO,CAACD,SAAS,EAAEG,OAAO,KACjD,IAAID,KAAKL,cAAcI,OAAO,CAACD,SAAS,EAAEG,OAAO;4BACvD,IAAIH,YAAYE,KAAKE,GAAG,IAAI;gCAC1BR,aAAaC,cAAcI,OAAO,CAACI,MAAM;4BAC3C;wBACF,EAAE,OAAM;4BACN,0BAA0B;4BAC1B,OAAO;gCAAEzD,MAAM;4BAAK;wBACtB;wBAEA,IAAI,CAACgD,YAAY;4BACf,OAAO;gCAAEhD,MAAM;4BAAK;wBACtB;wBAEA,6CAA6C;wBAC7C,MAAM0D,WAAW,MAAMd,QAAQe,IAAI,CAAC;4BAClCC,YAAY;4BACZC,OAAO;4BACPC,OAAO;gCAAEd,YAAY;oCAAEe,QAAQf;gCAAW;4BAAE;wBAC9C;wBACA,MAAMgB,MACJN,SAASO,IAAI,CAAC,EAAE,IACf,MAAMrB,QAAQX,MAAM,CAAC;4BACpB2B,YAAY;4BACZM,MAAM;gCAAElB;4BAAW;wBACrB;wBAEF,OAAO;4BAAEhD,MAAM;gCAAE4D,YAAY;gCAAS,GAAGI,GAAG;4BAAC;wBAAE;oBACjD;gBACF;aACD;QACH;QACAG,QAAQ;YACN;gBAAEzB,MAAM;gBAAc0B,MAAM;gBAAQC,OAAO;gBAAMC,UAAU;gBAAMC,QAAQ;YAAK;YAC9E;gBACE7B,MAAM;gBACN0B,MAAM;YACR;SACD;QACDI,OAAO;YACLC,cAAc;gBACZ,OAAO,EAAEP,IAAI,EAAEQ,SAAS,EAAEC,WAAW,EAAE5E,GAAG,EAAE;oBAC1C,IAAI2E,cAAc,UAAU;wBAC1B,4DAA4D;wBAC5D,MAAMxD,MAAMnB,IAAIoB,OAAO,CAACC,KAAK;wBAC7B,MAAMwD,eAAe;4BAAEC,IAAI;4BAAUpB,QAAQS,KAAKlB,UAAU;wBAAC;wBAC7D,IAAI,CAAC9B,OAAO,CAAC3B,gBAAgBqF,cAAc1D,KAAK1B,kBAAkB;4BAChE,OAAOsF,QAAQC,MAAM,CAAC,IAAIzF,SAAS;wBACrC;wBACA,iCAAiC;wBACjC,MAAMoC,cAAcV,SAASE,IAAIO,KAAK;oBACxC,OAAO,IAAIiD,cAAc,UAAU;wBACjC,4DAA4D;wBAC5D,MAAMxD,MAAMnB,IAAIoB,OAAO,CAACC,KAAK;wBAC7B,MAAMqC,SAASkB,aAAa3B,cAAckB,KAAKlB,UAAU;wBACzD,MAAM4B,eAAe;4BAAEC,IAAI;4BAAUpB;wBAAO;wBAC5C,IAAI,CAACvC,OAAO,CAAC3B,gBAAgBqF,cAAc1D,KAAK1B,kBAAkB;4BAChE,OAAOsF,QAAQC,MAAM,CAAC,IAAIzF,SAAS;wBACrC;wBACA,iCAAiC;wBACjC,MAAMoC,cAAcV,SAASE,IAAIO,KAAK;oBACxC;oBACA,OAAOyC;gBACT;aACD;YACDc,cAAc;gBACZ,OAAO,EAAEC,EAAE,EAAElF,GAAG,EAAE;oBAChB,8CAA8C;oBAC9C,MAAMiE,MAAM,MAAMjE,IAAI6C,OAAO,CAACsC,QAAQ,CAAC;wBACrCD;wBACArB,YAAY;oBACd;oBAEA,MAAM1C,MAAMnB,IAAIoB,OAAO,CAACC,KAAK;oBAC7B,MAAMwD,eAAe;wBAAEC,IAAI;wBAAUpB,QAAQO,IAAIhB,UAAU;oBAAC;oBAC5D,IAAI,CAAC9B,OAAO,CAAC3B,gBAAgBqF,cAAc1D,KAAK1B,kBAAkB;wBAChE,OAAOsF,QAAQC,MAAM,CAAC,IAAIzF,SAAS;oBACrC;oBACA,iCAAiC;oBACjC,MAAMoC,cAAcV,SAASE,IAAIO,KAAK;gBACxC;aACD;QACH;QACA0D,YAAY;IACd;AACF"}