{"version":3,"sources":["../../src/eventBus/RedisEventBus.ts"],"sourcesContent":["/**\n * Redis-backed EventBus using Pub/Sub for real-time distributed communication.\n *\n * Uses Redis Pub/Sub for instant event delivery across multiple servers/processes.\n *\n * Suitable for:\n * - Multi-server / distributed deployments\n * - Production environments requiring horizontal scaling\n * - Any environment where servers don't share filesystem access\n *\n * Requires a Redis server with Pub/Sub support.\n *\n * Note: User sync is handled entirely by the reconcile queue on the Better Auth side.\n * The queue processes ensure/delete tasks with retries when users change.\n */\nimport type { EventBus, TimestampHandler } from './types'\n\n/**\n * Minimal Redis client interface for Pub/Sub operations.\n * Compatible with ioredis.\n *\n * Note: Redis Pub/Sub requires separate connections for publishing and subscribing.\n * The subscriber connection enters \"subscriber mode\" and can't be used for other commands.\n */\nexport interface RedisPubSubClient {\n  /**\n   * Register a message handler.\n   * The handler receives (channel, message) arguments.\n   */\n  on(event: 'message', callback: (channel: string, message: string) => void): void\n\n  /**\n   * Publish a message to a channel.\n   */\n  publish(channel: string, message: string): Promise<number>\n\n  /**\n   * Subscribe to a channel.\n   */\n  subscribe(channel: string): Promise<unknown>\n\n  /**\n   * Unsubscribe from a channel.\n   */\n  unsubscribe(channel: string): Promise<unknown>\n}\n\nexport interface RedisEventBusOptions {\n  /**\n   * Channel prefix for Redis Pub/Sub.\n   * @default 'eventbus:'\n   */\n  channelPrefix?: string\n\n  /**\n   * Redis client for publishing events.\n   * Can be the same instance used for other operations.\n   *\n   * @example\n   * import Redis from 'ioredis'\n   * const publisher = new Redis()\n   */\n  publisher: RedisPubSubClient\n\n  /**\n   * Redis client for subscribing to events.\n   * **MUST be a dedicated connection** - Redis clients in subscriber mode\n   * cannot be used for other commands.\n   *\n   * @example\n   * import Redis from 'ioredis'\n   * const subscriber = new Redis() // Separate connection\n   */\n  subscriber: RedisPubSubClient\n}\n\nconst GLOBAL_KEY = '__payloadBetterAuthRedisEventBus__'\n\ninterface RedisEventBusState {\n  initialized: boolean\n  subscribedChannels: Set<string>\n  timestampHandlers: Map<string, Set<TimestampHandler>>\n}\n\nfunction getOrCreateState(): RedisEventBusState {\n  const g = globalThis as unknown as { [GLOBAL_KEY]?: RedisEventBusState }\n\n  if (!g[GLOBAL_KEY]) {\n    g[GLOBAL_KEY] = {\n      initialized: false,\n      subscribedChannels: new Set(),\n      timestampHandlers: new Map(),\n    }\n  }\n\n  return g[GLOBAL_KEY]\n}\n\n/**\n * Create a Redis-backed EventBus using Pub/Sub for real-time distributed communication.\n *\n * **Recommended for production and staging environments.**\n *\n * Uses Redis Pub/Sub for instant event delivery, making it suitable for\n * multi-server deployments where processes don't share filesystem access.\n *\n * **Important:** You must provide two separate Redis connections:\n * - `publisher`: For sending events (can be shared with other operations)\n * - `subscriber`: Dedicated connection for receiving events (enters subscriber mode)\n *\n * @example\n * ```typescript\n * import Redis from 'ioredis'\n * import { createRedisEventBus } from 'payload-better-auth/eventBus'\n *\n * const publisher = new Redis(process.env.REDIS_URL)\n * const subscriber = new Redis(process.env.REDIS_URL) // Separate connection!\n *\n * export const eventBus = createRedisEventBus({ publisher, subscriber })\n * ```\n */\nexport function createRedisEventBus(options: RedisEventBusOptions): EventBus {\n  const { channelPrefix = 'eventbus:', publisher, subscriber } = options\n\n  const state = getOrCreateState()\n\n  // Set up message handler only once\n  if (!state.initialized) {\n    subscriber.on('message', (channel: string, message: string) => {\n      // Parse channel to extract service name\n      // Channel format: \"eventbus:timestamp:<service>\"\n      const timestampPrefix = `${channelPrefix}timestamp:`\n      if (channel.startsWith(timestampPrefix)) {\n        const service = channel.slice(timestampPrefix.length)\n        const timestamp = parseInt(message, 10)\n\n        if (!isNaN(timestamp)) {\n          const handlers = state.timestampHandlers.get(service)\n          if (handlers) {\n            handlers.forEach((handler) => handler(timestamp))\n          }\n        }\n      }\n    })\n\n    state.initialized = true\n  }\n\n  return {\n    notifyTimestampChange(service: string, timestamp: number): void {\n      const channel = `${channelPrefix}timestamp:${service}`\n\n      // Publish asynchronously - fire and forget\n      publisher.publish(channel, String(timestamp)).catch((err) => {\n        // eslint-disable-next-line no-console\n        console.error('[RedisEventBus] Failed to publish timestamp change:', err)\n      })\n\n      // Also notify local handlers immediately (for same-process performance)\n      const handlers = state.timestampHandlers.get(service)\n      if (handlers) {\n        handlers.forEach((handler) => handler(timestamp))\n      }\n    },\n\n    subscribeToTimestamp(service: string, handler: TimestampHandler): () => void {\n      const channel = `${channelPrefix}timestamp:${service}`\n\n      // Initialize handlers set for this service\n      if (!state.timestampHandlers.has(service)) {\n        state.timestampHandlers.set(service, new Set())\n      }\n\n      state.timestampHandlers.get(service)!.add(handler)\n\n      // Subscribe to Redis channel if not already subscribed\n      if (!state.subscribedChannels.has(channel)) {\n        state.subscribedChannels.add(channel)\n        subscriber.subscribe(channel).catch((err) => {\n          // eslint-disable-next-line no-console\n          console.error('[RedisEventBus] Failed to subscribe to channel:', err)\n        })\n      }\n\n      // Return unsubscribe function\n      return () => {\n        state.timestampHandlers.get(service)?.delete(handler)\n\n        // If no more handlers for this service, unsubscribe from Redis\n        const handlers = state.timestampHandlers.get(service)\n        if (!handlers || handlers.size === 0) {\n          state.subscribedChannels.delete(channel)\n          subscriber.unsubscribe(channel).catch((err) => {\n            // eslint-disable-next-line no-console\n            console.error('[RedisEventBus] Failed to unsubscribe from channel:', err)\n          })\n        }\n      }\n    },\n  }\n}\n"],"names":["GLOBAL_KEY","getOrCreateState","g","globalThis","initialized","subscribedChannels","Set","timestampHandlers","Map","createRedisEventBus","options","channelPrefix","publisher","subscriber","state","on","channel","message","timestampPrefix","startsWith","service","slice","length","timestamp","parseInt","isNaN","handlers","get","forEach","handler","notifyTimestampChange","publish","String","catch","err","console","error","subscribeToTimestamp","has","set","add","subscribe","delete","size","unsubscribe"],"mappings":"AAAA;;;;;;;;;;;;;;CAcC,GA8DD,MAAMA,aAAa;AAQnB,SAASC;IACP,MAAMC,IAAIC;IAEV,IAAI,CAACD,CAAC,CAACF,WAAW,EAAE;QAClBE,CAAC,CAACF,WAAW,GAAG;YACdI,aAAa;YACbC,oBAAoB,IAAIC;YACxBC,mBAAmB,IAAIC;QACzB;IACF;IAEA,OAAON,CAAC,CAACF,WAAW;AACtB;AAEA;;;;;;;;;;;;;;;;;;;;;;CAsBC,GACD,OAAO,SAASS,oBAAoBC,OAA6B;IAC/D,MAAM,EAAEC,gBAAgB,WAAW,EAAEC,SAAS,EAAEC,UAAU,EAAE,GAAGH;IAE/D,MAAMI,QAAQb;IAEd,mCAAmC;IACnC,IAAI,CAACa,MAAMV,WAAW,EAAE;QACtBS,WAAWE,EAAE,CAAC,WAAW,CAACC,SAAiBC;YACzC,wCAAwC;YACxC,iDAAiD;YACjD,MAAMC,kBAAkB,GAAGP,cAAc,UAAU,CAAC;YACpD,IAAIK,QAAQG,UAAU,CAACD,kBAAkB;gBACvC,MAAME,UAAUJ,QAAQK,KAAK,CAACH,gBAAgBI,MAAM;gBACpD,MAAMC,YAAYC,SAASP,SAAS;gBAEpC,IAAI,CAACQ,MAAMF,YAAY;oBACrB,MAAMG,WAAWZ,MAAMP,iBAAiB,CAACoB,GAAG,CAACP;oBAC7C,IAAIM,UAAU;wBACZA,SAASE,OAAO,CAAC,CAACC,UAAYA,QAAQN;oBACxC;gBACF;YACF;QACF;QAEAT,MAAMV,WAAW,GAAG;IACtB;IAEA,OAAO;QACL0B,uBAAsBV,OAAe,EAAEG,SAAiB;YACtD,MAAMP,UAAU,GAAGL,cAAc,UAAU,EAAES,SAAS;YAEtD,2CAA2C;YAC3CR,UAAUmB,OAAO,CAACf,SAASgB,OAAOT,YAAYU,KAAK,CAAC,CAACC;gBACnD,sCAAsC;gBACtCC,QAAQC,KAAK,CAAC,uDAAuDF;YACvE;YAEA,wEAAwE;YACxE,MAAMR,WAAWZ,MAAMP,iBAAiB,CAACoB,GAAG,CAACP;YAC7C,IAAIM,UAAU;gBACZA,SAASE,OAAO,CAAC,CAACC,UAAYA,QAAQN;YACxC;QACF;QAEAc,sBAAqBjB,OAAe,EAAES,OAAyB;YAC7D,MAAMb,UAAU,GAAGL,cAAc,UAAU,EAAES,SAAS;YAEtD,2CAA2C;YAC3C,IAAI,CAACN,MAAMP,iBAAiB,CAAC+B,GAAG,CAAClB,UAAU;gBACzCN,MAAMP,iBAAiB,CAACgC,GAAG,CAACnB,SAAS,IAAId;YAC3C;YAEAQ,MAAMP,iBAAiB,CAACoB,GAAG,CAACP,SAAUoB,GAAG,CAACX;YAE1C,uDAAuD;YACvD,IAAI,CAACf,MAAMT,kBAAkB,CAACiC,GAAG,CAACtB,UAAU;gBAC1CF,MAAMT,kBAAkB,CAACmC,GAAG,CAACxB;gBAC7BH,WAAW4B,SAAS,CAACzB,SAASiB,KAAK,CAAC,CAACC;oBACnC,sCAAsC;oBACtCC,QAAQC,KAAK,CAAC,mDAAmDF;gBACnE;YACF;YAEA,8BAA8B;YAC9B,OAAO;gBACLpB,MAAMP,iBAAiB,CAACoB,GAAG,CAACP,UAAUsB,OAAOb;gBAE7C,+DAA+D;gBAC/D,MAAMH,WAAWZ,MAAMP,iBAAiB,CAACoB,GAAG,CAACP;gBAC7C,IAAI,CAACM,YAAYA,SAASiB,IAAI,KAAK,GAAG;oBACpC7B,MAAMT,kBAAkB,CAACqC,MAAM,CAAC1B;oBAChCH,WAAW+B,WAAW,CAAC5B,SAASiB,KAAK,CAAC,CAACC;wBACrC,sCAAsC;wBACtCC,QAAQC,KAAK,CAAC,uDAAuDF;oBACvE;gBACF;YACF;QACF;IACF;AACF"}