{"version":3,"sources":["../../src/eventBus/SqlitePollingEventBus.ts"],"sourcesContent":["/**\n * SQLite-backed EventBus with polling for cross-process communication.\n *\n * Uses Node.js 22+ native `node:sqlite` to share timestamp events across multiple\n * processes via a shared database file with periodic polling.\n *\n * Suitable for:\n * - Development with Turbopack multi-worker setups\n * - Production with multiple processes (PM2 cluster, etc.)\n * - Any environment where processes share filesystem access\n *\n * Trade-offs:\n * - Higher latency than in-memory (polling interval)\n * - File I/O overhead\n * - For true distributed systems (multiple machines), use Redis instead\n *\n * Note: User sync is handled entirely by the reconcile queue on the Better Auth side.\n * The queue processes ensure/delete tasks with retries when users change.\n */\nimport type { EventBus, TimestampHandler } from './types'\n\n/**\n * Minimal SQLite database interface.\n * Compatible with Node.js 22+ native `node:sqlite` DatabaseSync.\n */\nexport interface SqliteDatabase {\n  exec(sql: string): void\n  prepare(sql: string): SqliteStatement\n}\n\nexport interface SqliteStatement {\n  all(...params: unknown[]): unknown[]\n  get(...params: unknown[]): unknown\n  run(...params: unknown[]): { changes: bigint | number; lastInsertRowid: bigint | number }\n}\n\nconst GLOBAL_KEY = '__payloadBetterAuthSqliteEventBus__'\n\ninterface SqliteEventBusState {\n  cleanupInterval: null | ReturnType<typeof setInterval>\n  initialized: boolean\n  lastTimestampEventId: number\n  pollingInterval: null | ReturnType<typeof setInterval>\n  timestampHandlers: Map<string, Set<TimestampHandler>>\n}\n\nfunction getOrCreateState(): SqliteEventBusState {\n  const g = globalThis as unknown as { [GLOBAL_KEY]?: SqliteEventBusState }\n\n  if (!g[GLOBAL_KEY]) {\n    g[GLOBAL_KEY] = {\n      cleanupInterval: null,\n      initialized: false,\n      lastTimestampEventId: 0,\n      pollingInterval: null,\n      timestampHandlers: new Map(),\n    }\n  }\n\n  return g[GLOBAL_KEY]\n}\n\nexport interface SqlitePollingEventBusOptions {\n  /**\n   * How long to keep events before cleanup (in milliseconds).\n   * @default 60000 (1 minute)\n   */\n  cleanupAge?: number\n\n  /**\n   * How often to run cleanup of old events (in milliseconds).\n   * @default 60000 (1 minute)\n   */\n  cleanupInterval?: number\n\n  /**\n   * SQLite database instance from Node.js 22+ native `node:sqlite`.\n   *\n   * @example\n   * import { DatabaseSync } from 'node:sqlite'\n   * const db = new DatabaseSync('.event-bus.db')\n   */\n  db: SqliteDatabase\n\n  /**\n   * How often to poll for new events (in milliseconds).\n   * Lower values = faster event delivery, higher CPU/IO usage.\n   * @default 100\n   */\n  pollInterval?: number\n}\n\n/**\n * Create a SQLite-backed EventBus with polling for cross-process communication.\n *\n * **Note:** This adapter is intended for development and testing only.\n * For staging and production environments, use a Redis-backed EventBus instead.\n *\n * Timestamp events are stored in SQLite and polled periodically, allowing multiple\n * processes to communicate through the shared database file.\n *\n * @example\n * ```typescript\n * import { DatabaseSync } from 'node:sqlite'\n * import { createSqlitePollingEventBus } from 'payload-better-auth/eventBus'\n *\n * const db = new DatabaseSync('.event-bus.db')\n * export const eventBus = createSqlitePollingEventBus({ db })\n * ```\n */\n/**\n * Helper to run a database operation with retry logic for \"database is locked\" errors.\n */\nfunction withRetry<T>(operation: () => T, maxRetries = 3): T {\n  let retries = maxRetries\n  while (retries > 0) {\n    try {\n      return operation()\n    } catch (error) {\n      if (\n        retries > 1 &&\n        error instanceof Error &&\n        (error.message.includes('database is locked') || error.message.includes('SQLITE_BUSY'))\n      ) {\n        retries--\n        // Small delay before retry using exponential backoff\n        const delay = (maxRetries - retries + 1) * 50 // 50ms, 100ms, 150ms\n        Atomics.wait(new Int32Array(new SharedArrayBuffer(4)), 0, 0, delay)\n      } else {\n        throw error\n      }\n    }\n  }\n  // This shouldn't be reached, but TypeScript needs it\n  throw new Error('Retry exhausted')\n}\n\nexport function createSqlitePollingEventBus(options: SqlitePollingEventBusOptions): EventBus {\n  const nodeEnv = process.env.NODE_ENV?.toLowerCase()\n  if (nodeEnv === 'staging' || nodeEnv === 'production') {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `\\n⚠️  [payload-better-auth] WARNING: SqlitePollingEventBus is not recommended for ${nodeEnv} environments.\\n` +\n        '   Use createRedisEventBus() for distributed/multi-server deployments.\\n',\n    )\n  }\n\n  const { cleanupAge = 60_000, cleanupInterval = 60_000, db, pollInterval = 100 } = options\n\n  const state = getOrCreateState()\n\n  // Initialize database schema only once\n  if (!state.initialized) {\n    // Enable WAL mode for better concurrent access from multiple processes\n    // This allows concurrent reads and writes from different processes\n    try {\n      db.exec('PRAGMA journal_mode=WAL')\n      db.exec('PRAGMA busy_timeout=5000') // Wait up to 5s if database is locked\n      db.exec('PRAGMA synchronous=NORMAL') // Slightly faster while still safe with WAL\n    } catch {\n      // Ignore PRAGMA errors (might fail in read-only mode or if already set)\n    }\n\n    withRetry(() => {\n      db.exec(`\n        CREATE TABLE IF NOT EXISTS eventbus_timestamp_events (\n          id INTEGER PRIMARY KEY AUTOINCREMENT,\n          service TEXT NOT NULL,\n          timestamp INTEGER NOT NULL,\n          created_at INTEGER NOT NULL DEFAULT (unixepoch('now') * 1000)\n        )\n      `)\n    })\n\n    // Index for efficient polling\n    withRetry(() => {\n      db.exec(`CREATE INDEX IF NOT EXISTS idx_timestamp_events_id ON eventbus_timestamp_events(id)`)\n    })\n\n    // Get the current max ID so we don't process old events on startup\n    const maxTimestampEvent = withRetry(\n      () =>\n        db.prepare('SELECT MAX(id) as max_id FROM eventbus_timestamp_events').get() as\n          | { max_id: null | number }\n          | undefined,\n    )\n\n    state.lastTimestampEventId = maxTimestampEvent?.max_id ?? 0\n    state.initialized = true\n  }\n\n  // Prepare statements\n  const insertTimestampEventStmt = db.prepare(`\n    INSERT INTO eventbus_timestamp_events (service, timestamp)\n    VALUES (?, ?)\n  `)\n\n  const selectNewTimestampEventsStmt = db.prepare(`\n    SELECT id, service, timestamp\n    FROM eventbus_timestamp_events\n    WHERE id > ?\n    ORDER BY id ASC\n  `)\n\n  const cleanupTimestampEventsStmt = db.prepare(`\n    DELETE FROM eventbus_timestamp_events WHERE created_at < ?\n  `)\n\n  // Poll for new events\n  function pollEvents(): void {\n    try {\n      // Poll timestamp events with retry logic\n      const timestampEvents = withRetry(\n        () =>\n          selectNewTimestampEventsStmt.all(state.lastTimestampEventId) as Array<{\n            id: number\n            service: string\n            timestamp: number\n          }>,\n      )\n\n      for (const row of timestampEvents) {\n        state.lastTimestampEventId = row.id\n\n        const handlers = state.timestampHandlers.get(row.service)\n        if (handlers) {\n          handlers.forEach((handler) => handler(row.timestamp))\n        }\n      }\n    } catch {\n      // Silently ignore polling errors - will retry on next interval\n    }\n  }\n\n  // Start polling if not already running\n  if (!state.pollingInterval) {\n    state.pollingInterval = setInterval(pollEvents, pollInterval)\n\n    if (typeof state.pollingInterval.unref === 'function') {\n      state.pollingInterval.unref()\n    }\n  }\n\n  // Start cleanup if not already running\n  if (!state.cleanupInterval) {\n    state.cleanupInterval = setInterval(() => {\n      try {\n        const cutoff = Date.now() - cleanupAge\n        withRetry(() => cleanupTimestampEventsStmt.run(cutoff))\n      } catch {\n        // Silently ignore cleanup errors - will retry on next interval\n      }\n    }, cleanupInterval)\n\n    if (typeof state.cleanupInterval.unref === 'function') {\n      state.cleanupInterval.unref()\n    }\n  }\n\n  return {\n    notifyTimestampChange(service: string, timestamp: number): void {\n      withRetry(() => insertTimestampEventStmt.run(service, timestamp))\n\n      // Also notify local handlers immediately (for same-process performance)\n      const handlers = state.timestampHandlers.get(service)\n      if (handlers) {\n        handlers.forEach((handler) => handler(timestamp))\n      }\n    },\n\n    subscribeToTimestamp(service: string, handler: TimestampHandler): () => void {\n      if (!state.timestampHandlers.has(service)) {\n        state.timestampHandlers.set(service, new Set())\n      }\n\n      state.timestampHandlers.get(service)!.add(handler)\n\n      return () => {\n        state.timestampHandlers.get(service)?.delete(handler)\n      }\n    },\n  }\n}\n"],"names":["GLOBAL_KEY","getOrCreateState","g","globalThis","cleanupInterval","initialized","lastTimestampEventId","pollingInterval","timestampHandlers","Map","withRetry","operation","maxRetries","retries","error","Error","message","includes","delay","Atomics","wait","Int32Array","SharedArrayBuffer","createSqlitePollingEventBus","options","nodeEnv","process","env","NODE_ENV","toLowerCase","console","warn","cleanupAge","db","pollInterval","state","exec","maxTimestampEvent","prepare","get","max_id","insertTimestampEventStmt","selectNewTimestampEventsStmt","cleanupTimestampEventsStmt","pollEvents","timestampEvents","all","row","id","handlers","service","forEach","handler","timestamp","setInterval","unref","cutoff","Date","now","run","notifyTimestampChange","subscribeToTimestamp","has","set","Set","add","delete"],"mappings":"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"}