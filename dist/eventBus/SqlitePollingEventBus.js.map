{"version":3,"sources":["../../src/eventBus/SqlitePollingEventBus.ts"],"sourcesContent":["/**\n * SQLite-backed EventBus with polling for cross-process communication.\n *\n * Uses Node.js 22+ native `node:sqlite` to share timestamp events across multiple\n * processes via a shared database file with periodic polling.\n *\n * Suitable for:\n * - Development with Turbopack multi-worker setups\n * - Production with multiple processes (PM2 cluster, etc.)\n * - Any environment where processes share filesystem access\n *\n * Trade-offs:\n * - Higher latency than in-memory (polling interval)\n * - File I/O overhead\n * - For true distributed systems (multiple machines), use Redis instead\n *\n * Note: User sync is handled entirely by the reconcile queue on the Better Auth side.\n * The queue processes ensure/delete tasks with retries when users change.\n */\nimport type { EventBus, TimestampHandler } from './types'\n\n/**\n * Minimal SQLite database interface.\n * Compatible with Node.js 22+ native `node:sqlite` DatabaseSync.\n */\nexport interface SqliteDatabase {\n  exec(sql: string): void\n  prepare(sql: string): SqliteStatement\n}\n\nexport interface SqliteStatement {\n  all(...params: unknown[]): unknown[]\n  get(...params: unknown[]): unknown\n  run(...params: unknown[]): { changes: bigint | number; lastInsertRowid: bigint | number }\n}\n\nconst GLOBAL_KEY = '__payloadBetterAuthSqliteEventBus__'\n\ninterface SqliteEventBusState {\n  cleanupInterval: null | ReturnType<typeof setInterval>\n  initialized: boolean\n  lastTimestampEventId: number\n  pollingInterval: null | ReturnType<typeof setInterval>\n  timestampHandlers: Map<string, Set<TimestampHandler>>\n}\n\nfunction getOrCreateState(): SqliteEventBusState {\n  const g = globalThis as unknown as { [GLOBAL_KEY]?: SqliteEventBusState }\n\n  if (!g[GLOBAL_KEY]) {\n    g[GLOBAL_KEY] = {\n      cleanupInterval: null,\n      initialized: false,\n      lastTimestampEventId: 0,\n      pollingInterval: null,\n      timestampHandlers: new Map(),\n    }\n  }\n\n  return g[GLOBAL_KEY]\n}\n\nexport interface SqlitePollingEventBusOptions {\n  /**\n   * How long to keep events before cleanup (in milliseconds).\n   * @default 60000 (1 minute)\n   */\n  cleanupAge?: number\n\n  /**\n   * How often to run cleanup of old events (in milliseconds).\n   * @default 60000 (1 minute)\n   */\n  cleanupInterval?: number\n\n  /**\n   * SQLite database instance from Node.js 22+ native `node:sqlite`.\n   *\n   * @example\n   * import { DatabaseSync } from 'node:sqlite'\n   * const db = new DatabaseSync('.event-bus.db')\n   */\n  db: SqliteDatabase\n\n  /**\n   * How often to poll for new events (in milliseconds).\n   * Lower values = faster event delivery, higher CPU/IO usage.\n   * @default 100\n   */\n  pollInterval?: number\n}\n\n/**\n * Create a SQLite-backed EventBus with polling for cross-process communication.\n *\n * **Note:** This adapter is intended for development and testing only.\n * For staging and production environments, use a Redis-backed EventBus instead.\n *\n * Timestamp events are stored in SQLite and polled periodically, allowing multiple\n * processes to communicate through the shared database file.\n *\n * @example\n * ```typescript\n * import { DatabaseSync } from 'node:sqlite'\n * import { createSqlitePollingEventBus } from 'payload-better-auth/eventBus'\n *\n * const db = new DatabaseSync('.event-bus.db')\n * export const eventBus = createSqlitePollingEventBus({ db })\n * ```\n */\nexport function createSqlitePollingEventBus(options: SqlitePollingEventBusOptions): EventBus {\n  const nodeEnv = process.env.NODE_ENV?.toLowerCase()\n  if (nodeEnv === 'staging' || nodeEnv === 'production') {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `\\n⚠️  [payload-better-auth] WARNING: SqlitePollingEventBus is not recommended for ${nodeEnv} environments.\\n` +\n        '   Use createRedisEventBus() for distributed/multi-server deployments.\\n',\n    )\n  }\n\n  const { cleanupAge = 60_000, cleanupInterval = 60_000, db, pollInterval = 100 } = options\n\n  const state = getOrCreateState()\n\n  // Initialize database schema only once\n  if (!state.initialized) {\n    db.exec(`\n      CREATE TABLE IF NOT EXISTS eventbus_timestamp_events (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        service TEXT NOT NULL,\n        timestamp INTEGER NOT NULL,\n        created_at INTEGER NOT NULL DEFAULT (unixepoch('now') * 1000)\n      )\n    `)\n\n    // Index for efficient polling\n    db.exec(`CREATE INDEX IF NOT EXISTS idx_timestamp_events_id ON eventbus_timestamp_events(id)`)\n\n    // Get the current max ID so we don't process old events on startup\n    const maxTimestampEvent = db\n      .prepare('SELECT MAX(id) as max_id FROM eventbus_timestamp_events')\n      .get() as { max_id: null | number } | undefined\n\n    state.lastTimestampEventId = maxTimestampEvent?.max_id ?? 0\n    state.initialized = true\n  }\n\n  // Prepare statements\n  const insertTimestampEventStmt = db.prepare(`\n    INSERT INTO eventbus_timestamp_events (service, timestamp)\n    VALUES (?, ?)\n  `)\n\n  const selectNewTimestampEventsStmt = db.prepare(`\n    SELECT id, service, timestamp\n    FROM eventbus_timestamp_events\n    WHERE id > ?\n    ORDER BY id ASC\n  `)\n\n  const cleanupTimestampEventsStmt = db.prepare(`\n    DELETE FROM eventbus_timestamp_events WHERE created_at < ?\n  `)\n\n  // Poll for new events\n  function pollEvents(): void {\n    // Poll timestamp events\n    const timestampEvents = selectNewTimestampEventsStmt.all(state.lastTimestampEventId) as Array<{\n      id: number\n      service: string\n      timestamp: number\n    }>\n\n    for (const row of timestampEvents) {\n      state.lastTimestampEventId = row.id\n\n      const handlers = state.timestampHandlers.get(row.service)\n      if (handlers) {\n        handlers.forEach((handler) => handler(row.timestamp))\n      }\n    }\n  }\n\n  // Start polling if not already running\n  if (!state.pollingInterval) {\n    state.pollingInterval = setInterval(pollEvents, pollInterval)\n\n    if (typeof state.pollingInterval.unref === 'function') {\n      state.pollingInterval.unref()\n    }\n  }\n\n  // Start cleanup if not already running\n  if (!state.cleanupInterval) {\n    state.cleanupInterval = setInterval(() => {\n      const cutoff = Date.now() - cleanupAge\n      cleanupTimestampEventsStmt.run(cutoff)\n    }, cleanupInterval)\n\n    if (typeof state.cleanupInterval.unref === 'function') {\n      state.cleanupInterval.unref()\n    }\n  }\n\n  return {\n    notifyTimestampChange(service: string, timestamp: number): void {\n      insertTimestampEventStmt.run(service, timestamp)\n\n      // Also notify local handlers immediately (for same-process performance)\n      const handlers = state.timestampHandlers.get(service)\n      if (handlers) {\n        handlers.forEach((handler) => handler(timestamp))\n      }\n    },\n\n    subscribeToTimestamp(service: string, handler: TimestampHandler): () => void {\n      if (!state.timestampHandlers.has(service)) {\n        state.timestampHandlers.set(service, new Set())\n      }\n\n      state.timestampHandlers.get(service)!.add(handler)\n\n      return () => {\n        state.timestampHandlers.get(service)?.delete(handler)\n      }\n    },\n  }\n}\n"],"names":["GLOBAL_KEY","getOrCreateState","g","globalThis","cleanupInterval","initialized","lastTimestampEventId","pollingInterval","timestampHandlers","Map","createSqlitePollingEventBus","options","nodeEnv","process","env","NODE_ENV","toLowerCase","console","warn","cleanupAge","db","pollInterval","state","exec","maxTimestampEvent","prepare","get","max_id","insertTimestampEventStmt","selectNewTimestampEventsStmt","cleanupTimestampEventsStmt","pollEvents","timestampEvents","all","row","id","handlers","service","forEach","handler","timestamp","setInterval","unref","cutoff","Date","now","run","notifyTimestampChange","subscribeToTimestamp","has","set","Set","add","delete"],"mappings":"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"}